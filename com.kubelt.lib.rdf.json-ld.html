<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.lib.rdf.json-ld</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Generate RDF/cljs quads from JSON-LD.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.rdf.json-ld
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  ;; This breaks web build
  #_(:require
   [&quot;jsonld&quot; :as jsonld])
  (:require
   [clojure.string :as str])
  (:require
   [com.kubelt.lib.rdf.util :as util]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>We use JavaScript package "jsonld" to parse JSON-LD data. https://github.com/digitalbazaar/jsonld.js</p><p>jsonld.compact(doc, context) jsonld.expand(compacted) jsonld.flatten(doc) jsonld.frame(doc, frame) jsonld.canonize(doc, {   algorithm: 'URDNA2015',   format: 'application/n-quads', })</p><p>NB: if we don't specify an RDF output format we get back the internal dataset, an array of quads: jsonld.toRDF(doc, {format: 'application/n-quads'})</p><p>jsonld.fromRDF(nquads, {format: 'application-n-quads'})</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Internal</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js named node term map to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- named-node-&gt;value
  [{:keys [termType value] :as m}]
  {:pre [(= termType &quot;NamedNode&quot;) (string? value)]}
  {:rdf/type :rdf.term/named-node
   :value value})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js literal term map to RDF/cljs format. The :language key is optional.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- literal-&gt;value
  [{:keys [termType language value] :as m}]
  {:pre [(= termType &quot;Literal&quot;)
         (or (nil? language) (string? language))
         (string? value)]}
  (let [datatype (named-node-&gt;value (:datatype m))
        lang-map (if language {:language language} {})]
    (merge {:rdf/type :rdf.term/literal
            :datatype datatype
            :value value}
           lang-map)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js default graph term map to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- default-graph-&gt;value
  [{:keys [termType value] :as m}]
  {:pre [(= termType &quot;DefaultGraph&quot;) (string? value)]}
  {:rdf/type :rdf.term/default-graph
   :value value})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js blank node term map to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- blank-node-&gt;value
  [{:keys [termType value] :as m}]
  {:pre [(= termType &quot;BlankNode&quot;) (string? value)]}
  (let [;; The standard requires that serialization prefixes be removed,
        ;; e.g. the &quot;_:&quot; included if the data was sourced from Turtle.
        value (util/remove-blank-prefix value)]
      {:rdf/type :rdf.term/blank-node
       :value value}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js variable term map to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- variable-&gt;value
  [{:keys [termType value] :as m}]
  {:pre [(= termType &quot;Variable&quot;) (string? value)]}
  {:rdf/type :rdf.term/variable
   :value value})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Forward declare this name.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(declare quad-&gt;value)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Takes a JavaScript object representing an RDF/js Term and turns it into the value that should be stored in our ClojureScript quad representation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- node-&gt;value
  [{:keys [termType] :as m}]
  {:pre [(some? termType)]}
  (condp = termType
    &quot;BlankNode&quot; (blank-node-&gt;value m)
    &quot;DefaultGraph&quot; (default-graph-&gt;value m)
    &quot;Literal&quot; (literal-&gt;value m)
    &quot;NamedNode&quot; (named-node-&gt;value m)
    &quot;Variable&quot; (variable-&gt;value m)
    &quot;Quad&quot; (quad-&gt;value m)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Takes a JavaScript object representing a quad, as returned by jsonld.js, and converts it into our standard map-based quad representation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- quad-&gt;value
  [{:keys [subject predicate object graph] :as quad-map}]
  (let [subject (node-&gt;value subject)
        predicate (node-&gt;value predicate)
        object (node-&gt;value object)
        graph (node-&gt;value graph)]
    (merge {:rdf/type :rdf.term/quad}
           #:rdf.quad {:subject subject
                       :predicate predicate
                       :object object
                       :graph graph})))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert RDF/js quads to RDF/cljs quads. Returns a promise that resolves to a vector of quad maps.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn js-&gt;graph
  [doc]
  (let [options (clj-&gt;js {})]
    ;; TODO replace jsonld dependency with something else; home grown?
    (js/Promise.resolve #js [])
    ;; jsonld.toRDF() returns a promise that resolves to a string
    ;; containing RDF triples.
    #_(-&gt; (.toRDF jsonld doc options)
        (.then (fn [dataset]
                 (js-&gt;clj dataset :keywordize-keys true)))
        (.then (fn [dataset]
                 (mapv quad-&gt;value dataset)))
        (.then (fn [quads]
                 {:rdf/type :rdf.type/graph
                  :quads quads})))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
