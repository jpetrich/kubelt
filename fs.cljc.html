<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">fs.cljc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Filesystem utilities for OpenRPC schemas.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc.schema.fs
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [clojure.string :as cstr])
  (:require
   [malli.core :as mc]
   [malli.transform :as mt])
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.json :as lib.json]
   [com.kubelt.rpc.schema.util :as rpc.schema.util]
   [com.kubelt.spec.rpc.schema :as spec.rpc.schema])
  #?(:node
     (:require
      [&quot;fs&quot; :refer [promises] :rename {promises fs-promises} :as fs]
      [com.kubelt.lib.promise :as lib.promise])))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>A decoding transformer, only mounting to :string schemas with truthy :string/trim property, e.g. [:string {:string/trim true :min 1}]</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn string-trimmer
  []
  (mt/transformer
   {:decoders
    {:string
     {:compile (fn [schema _]
                 (let [{:string/keys [trim]} (mc/properties schema)]
                   (when trim #(cond-&gt; % (string? %) cstr/trim))))}}}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def key-decoder
  (mt/key-transformer {:decode rpc.schema.util/s-&gt;kw}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a parsed schema as an edn value, clean it up and validate against our schema. If any errors are detected, an error map is returned, otherwise the transformed schema is returned.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn conform
  [edn]
  (let [tf (mt/transformer #_mt/strip-extra-keys-transformer
                           mt/string-transformer
                           mt/json-transformer
                           string-trimmer
                           key-decoder)
        clean-edn (mc/decode spec.rpc.schema/schema edn tf)]
    (if-not (mc/validate spec.rpc.schema/schema clean-edn)
      (lib.error/explain spec.rpc.schema/schema clean-edn)
      clean-edn)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Load an OpenRPC schema from a file. Validates the OpenRPC schema and returns an error map if any issues were detected. Otherwise, returns the schema as a map whose keys have been keywordized and converted to kebab case.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn read-file&amp;
  [filename]
  #?(:browser nil
     :node (.readFile fs-promises filename)
     :clj
     (slurp filename)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>read-schema</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Load an OpenRPC schema from a file. Validates the OpenRPC schema and returns an error map if any issues were detected. Otherwise, returns the schema as a map whose keys have been keywordized and converted to kebab case.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn read-schema
  [filename]
  #?(:browser nil
     :node (lib.promise/promise
            (fn [resolve reject]
              (-&gt; (read-file&amp; filename)
                  (lib.promise/then #(resolve (conform (lib.json/json-str-&gt;edn % lib.json/keyword-mapper))))
                  (lib.promise/catch reject))))
     :clj
     (let [json-str (read-file&amp; filename)
           keywordize? true
           edn (lib.json/from-json json-str keywordize?)]
       (conform edn))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
