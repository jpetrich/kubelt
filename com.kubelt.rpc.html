<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.rpc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Entry point for a JSON-RPC client.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [clojure.set :as cset])
  (:require
   [malli.core :as malli])
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.http :as lib.http]
   [com.kubelt.proto.http :as proto.http]
   [com.kubelt.rpc.client :as rpc.client]
   [com.kubelt.rpc.http :as rpc.http]
   [com.kubelt.rpc.path :as rpc.path]
   [com.kubelt.rpc.request :as rpc.request]
   [com.kubelt.rpc.schema :as rpc.schema]
   [com.kubelt.spec :as spec]
   [com.kubelt.spec.openrpc :as spec.openrpc]
   [com.kubelt.spec.rpc :as spec.rpc]
   [com.kubelt.spec.rpc.available :as spec.rpc.available]
   [com.kubelt.spec.rpc.call :as spec.rpc.call]
   [com.kubelt.spec.rpc.client :as spec.rpc.client]
   [com.kubelt.spec.rpc.discover :as spec.rpc.discover]
   [com.kubelt.spec.rpc.doc :as spec.rpc.doc]
   [com.kubelt.spec.rpc.execute :as spec.rpc.execute]
   [com.kubelt.spec.rpc.inflate :as spec.rpc.inflate]
   [com.kubelt.spec.rpc.init :as spec.rpc.init]
   [com.kubelt.spec.rpc.request :as spec.rpc.request]
   [com.kubelt.spec.rpc.schema :as spec.rpc.schema]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO check version of supplied schema to ensure we support it</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO rather than injecting a provider URL, use the server URL template feature defined in the OpenRPC spec.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>init</h2>TODO add option to provide set of "dividing" characters, e.g. _, .<ul><li>"eth_sync" => [:eth :sync]</li><li>"rpc.provider" => [:rpc :provider]</li></ul><p>TODO add option for using a prefix, e.g. {:method/prefix :xxx}</p><ul><li>"eth_sync" => [:xxx :eth :sync]</li></ul><p>TODO if user wants to inject an existing HTTP client, should it go into the options map (as things are now) or via a separate parameter (var args, multi-arity).</p><p>TODO pass in http client as separate, optional argument rather than including in options map?</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Create a JSON-RPC client.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  ([]
   (let [defaults {}]
     (init defaults)))
  ([options]
   (lib.error/conform*
    [spec.rpc.init/options options]
    ;; TODO url not currently used! It may make sense to use the
    ;; OpenRPC &quot;Server&quot; block to configure RPC endpoints using URL
    ;; templates.
    (let [user-agent (rpc.http/user-agent 0 0 1)
          ;; Create an HTTP client (use the one in the options map, if provided).
          http-client (if-not (contains? options :http/client)
                        (lib.http/client)
                        (:http/client options))
          defaults {:http/user-agent user-agent}
          ;; Remove the HTTP client and use defaults for any option
          ;; values not supplied.
          options (as-&gt; options \$
                    (dissoc \$ :http/client)
                    (merge defaults \$))]
      (rpc.client/init http-client options)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>available</h2>The intent of this function is to provide a pleasant REPL-drivendeveloper experience. A user should be able to instantiate or receivea client, and use this method to discover what calls it supports bylisting everything, searching/filtering based on variousattributes (initially the API call name or "path"), and sorting theoutput to obtain a single API method name that can be passed tothe (doc) function to obtain more detailed documentation as data orpossibly in a pretty output format.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the collection of operations provided by the API. Each vector of keywords in the returned collection represents a call that may be performed. If a vector of keywords is provided as the 'path' argument, it is used as a prefix to filter the set of methods that are returned. Use the (doc) function to get a more detailed description of a single API resource. The options parameter can be supplied to filter or transform the data that is returned.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn available
  ([client]
   (let [path []]
     (available client path)))
  ([client path]
   (let [defaults {:methods/sort? true}]
     (available client path defaults)))
  ([client path options]
   (lib.error/conform*
    [spec.rpc.client/client client]
    [spec.rpc/path path]
    [spec.rpc.available/options options]
    (let [sort? (get options :methods/sort?)
          depth (get options :methods/depth)
          search (get options :methods/search)
          ;; This is a map from {prefix rpc-schema}. Note that
          ;; rpc-schema is itself a map from &quot;path&quot; (a vector of
          ;; keywords that names an RPC method) to a value that
          ;; describes the method.
          rpc-schemas (get client :rpc/schemas {})
          ;; When no explicit prefix is set, the prefix associated with
          ;; the corresponding schema is ::rpc.schema/default. This is
          ;; to accommodate the common situation where there is only one
          ;; schema being used with the client. In this case we use the
          ;; paths from the schema untouched (not adding the prefix
          ;; keyword to the path vector).
          path-set (reduce
                    (fn [path-set [prefix rpc-schema]]
                      (let [add-prefix (fn [v] (into [prefix] v))
                            paths (into #{} (keys (get rpc-schema :rpc/methods)))
                            paths (if (= prefix ::rpc.schema/default)
                                    paths
                                    (into #{} (map add-prefix paths)))]
                        (cset/union path-set paths)))
                    #{} rpc-schemas)
          ;; Apply the filtering and selection criteria that the caller
          ;; supplied to winnow the results.
          path-set (cond-&gt; path-set
                     ;; depth
                     (and (integer? depth) (&gt;= depth 0))
                     (rpc.path/filter-depth depth)
                     ;; search
                     (string? search)
                     (rpc.path/filter-search search)
                     ;; prefix
                     (not-empty path)
                     (rpc.path/filter-prefix path))]
      (if sort?
        (apply sorted-set path-set)
        path-set)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>doc</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method path (a vector of keywords) return a map that describes it.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn doc
  ([client path]
   (let [defaults {}]
     (doc client path defaults)))
  ([client path options]
   (lib.error/conform*
    [spec.rpc.client/client client]
    [spec.rpc/path path]
    [spec.rpc.doc/options options]
    (let [path-set (available client path)
          path-count (count path-set)]
      ;; Calling (available) returns a set of paths that match a path
      ;; prefix, i.e. [:foo] will match all paths like [:foo ...]. We
      ;; pass a full path so the returned set should have only a single
      ;; entry if the path exists.
      (cond
        ;; Returned path set was empty so the path isn't there.
        (= 0 path-count)
        (let [message {:message &quot;missing method&quot; :method path}]
          (lib.error/error message))
        ;; There's more than one path in the path set, implying we were
        ;; given a partial path prefix and not a full path.
        (&gt; path-count 1)
        (let [message {:message &quot;too many matches&quot; :method path}]
          (lib.error/error message))
        ;; Just one path was in the set, so that's what we'll lookup and
        ;; return documentation for.
        :else
        (letfn []
          (let [method (rpc.client/find-method client path)
                method-raw (get method :method/raw)]
            ;; TODO Support an :output/format option to optionally
            ;; provide alternately formatted versions of documentation.
            method-raw)))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>prepare</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a request map describing the RPC call to perform. The supplied parameters are validated against the service schema and an error map is returned if any issues are detected.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn prepare
  [client path params]
  ;; Use lib.error/conform* to ensure that each argument matches
  ;; its schema.
  (lib.error/conform*
   [spec.rpc.client/client client]
   [spec.rpc/path path]
   [spec.rpc/params params]
   ;; TODO add macro for guards, i.e. to check the results of a
   ;; collection of predicates and return meaningful errors when they
   ;; fail. Maybe something like: (guards [() () ... ()] (body)).
   (if-let [method (rpc.client/find-method client path)]
     (let [options (get client :init/options)]
       ;; NB does not yet validate params.
       (rpc.request/from-method path method params options))
     (lib.error/error {:message &quot;no such RPC method&quot; :method path}))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>execute</h2>options:<ul><li>explicit request ID</li><li>override provider URL</li><li>request timeout</li></ul>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Execute a prepared RPC request.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn execute
  ([client request]
    (let [defaults {}]
      (execute client request defaults)))
  ([client request options]
   (lib.error/conform*
    [spec.rpc.client/client client]
    [spec.rpc.request/request request]
    [spec.rpc.execute/options options]
    (let [http-client (get client :http/client)
          http-request (get request :http/request)]
      ;; TODO including a request body breaks, fix before performing
      ;; request.
      http-request
      ;; TODO validate result
      ;; :node/browser Returns a promise.
      ;; :jvm Returns a future.
      ;;(proto.http/request! http-client http-request)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>call</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Invoke an RPC method. Any error encountered in the supplied parameters results in an error map being returned without any request being performed.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn call
  ([client path params]
   (let [defaults {}]
     (call client path params defaults)))
  ([client path params options]
   (lib.error/conform*
    [spec.rpc.client/client client]
    [spec.rpc/path path]
    [spec.rpc/params params]
    [spec.rpc.call/options options]
    (let [request (prepare client path params)]
      (if (lib.error/error? request)
        request
        (execute client request))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>rpc-fn</h2>TODO is this useful for developers?
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a function that implements the given RPC call and which accepts the expected parameters and returns the expected result.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn rpc-fn
  ([client path]
   (let [defaults {}]
     (rpc-fn client path defaults)))
  ([client path options]
   (lib.error/conform*
    [spec.rpc.client/client client]
    [spec.rpc/path path]
    [spec.rpc.call/options options]
    ;; The returned function should invoke the RPC method named by the
    ;; path argument, assuming that it exists on the client.
    ;; - should we require a single parameter map, or allow the user to
    ;;   supply arguments as varargs? [params] vs. [&amp; params]
    (fn [params]
      ;; This validates the parameters and returns an error map if
      ;; any issue(s) were detected.
      (call client path params options)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
