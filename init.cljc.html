<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">init.cljc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>SDK system map implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.init
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [integrant.core :as ig]
   [taoensso.timbre :as log])
  (:require
   [com.kubelt.ipfs.client :as ipfs.client]
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.integrant :as lib.integrant]
   [com.kubelt.lib.jwt :as lib.jwt]
   [com.kubelt.lib.promise :as lib.promise]
   [com.kubelt.lib.vault :as lib.vault]
   [com.kubelt.lib.wallet :as lib.wallet]
   [com.kubelt.proto.http :as proto.http])
  (:require
   #?@(:browser [[com.kubelt.lib.http.browser :as http.browser]]
       :node [[com.kubelt.lib.http.node :as http.node]]
       :clj [[com.kubelt.lib.http.jvm :as http.jvm]])))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>System</h2>For each key in the system map, if a corresponding method isimplemented for the ig/init-key multimethod it will be invoked inorder to initialize that part of the system. The return value isstored as part of the system configuration map. Initialization isperformed recursively, making it possible to have nested subsystems.<p>If methods are defined for the ig/halt-key! multimethod, they are invoked in order to tear down the system in the reverse order in which it was initialized.</p><p>To begin the system:   (integrant.core/init) To stop the system:   (integrant.core/halt!)</p><p>Cf. https://github.com/weavejester/integrant.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:log/level</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :log/level [_ log-level]
  ;; Initialize the logging system.
  (when log-level
    (log/merge-config! {:min-level log-level}))
  log-level)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :log/level [_ log-level]
  (log/debug {:log/msg &quot;halt logging&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.read/scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.read/host</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/host [_ host]
  host)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.read/port</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/port [_ port]
  port)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.write/scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.write/host</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/host [_ host]
  host)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs.write/port</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/port [_ port]
  port)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/host</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/host [_ host]
  host)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/port</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/port [_ port]
  port)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:credential/jwt</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :credential/jwt [_ tokens]
  tokens)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/http</h2>TODO support custom user agent string.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/http [_ value]
  {:post [(not (nil? %))]}
  (log/debug {:log/msg &quot;init HTTP client&quot;})
  #?(:browser (http.browser/-&gt;HttpClient)
     :node (http.node/-&gt;HttpClient)
     :clj (http.jvm/-&gt;HttpClient)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/http [_ client]
  {:pre [(satisfies? proto.http/HttpClient client)]}
  (log/debug {:log/msg &quot;halt HTTP client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/ipfs</h2>Send headers with each request: token "xyzabc123" authorization (str "Bearer " token) user-agent "X-Kubelt" headers {:headers {:authorization authorization<pre><code>                :user-agent user-agent}}</code></pre>Use an http.Agent (node-only) to control client behavior:  agent {:agent (.. http Agent.)}
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/ipfs [_ value]
  (let [;; Supply the address of the IPFS node(s). Read and write can
        ;; use different paths if desired, e.g. when you want to read
        ;; from a local daemon but write to a remote service for
        ;; pinning.
        read-scheme (get-in value [:ipfs/read :http/scheme])
        read-host (get-in value [:ipfs/read :http/host])
        read-port (get-in value [:ipfs/read :http/port])
        write-scheme (get-in value [:ipfs/write :http/scheme])
        write-host (get-in value [:ipfs/write :http/host])
        write-port (get-in value [:ipfs/write :http/port])
        ;; Get the platform-specific HTTP client.
        http-client (get value :client/http)
        make-url (fn [scheme host port]
                   (str (name read-scheme) &quot;://&quot; read-host &quot;:&quot; read-port))
        ipfs-read (make-url read-scheme read-host read-port)
        ipfs-write (make-url write-scheme write-host write-port)]
    (log/debug {:log/msg &quot;init IPFS client&quot; :ipfs/read ipfs-read :ipfs/write ipfs-write})
    ;; Create the options object we pass to client creation fn.
    #?(:cljs
       (let [options {:http/client http-client
                      :read/scheme read-scheme
                      :read/host read-host
                      :read/port read-port
                      :write/scheme write-scheme
                      :write/host write-host
                      :write/port write-port
                      ;; Set a global timeout for *all* requests:
                      ;;:client/timeout 5000
                      }]
         (-&gt; (ipfs.client/init options)
             (lib.promise/then (fn [x] (lib.promise/resolved x)))
             (lib.promise/catch (fn [e]
                                  (log/fatal ::error e)
                                  (log/fatal ::mocking-ipfs-client &quot;TODO: FIX IN CI&quot;)
                                  (lib.promise/resolved
                                   {:com.kubelt/type :kubelt.type/ipfs-client
                                    :http/client :mock
                                    :node/read &quot;http:///ip4/127.0.0.1/tcp/5001&quot;
                                    :node/write &quot;http:///ip4/127.0.0.1/tcp/5001&quot;}))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/ipfs [_ client]
  (log/debug {:log/msg &quot;halt IPFS client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/p2p</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/p2p [_ {:keys [http/scheme http/host http/port] :as value}]
  ;; TODO initialize an RPC client using the given coordinates once
  ;; local client is fleshed out.
  (let [address (str (name scheme) &quot;://&quot; host &quot;:&quot; port)]
    (log/debug {:log/msg &quot;init p2p client&quot; :p2p/address address})
    value))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/p2p [_ value]
  (log/debug {:log/msg &quot;halt p2p client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/session</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/session [_ {:keys [jwt/tokens]}]
  (log/debug {:log/msg &quot;init session&quot;})
  ;; If any JWTs are provided, parse them and store the decoded result.
  (let [tokens (reduce (fn [m [core token]]
                         (let [decoded (lib.jwt/decode token)]
                           (assoc m core decoded)))
                       {}
                       tokens)]
    ;; Our session storage map is a &quot;vault&quot;.
    (lib.vault/vault tokens)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/session [_ session]
  (log/debug {:log/msg &quot;halt session&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/wallet</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;init wallet&quot;})
  (if-not (lib.wallet/valid? wallet)
    (throw (ex-info &quot;invalid wallet&quot; wallet))
    wallet))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;halt wallet&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>NB: the configuration map is validated by the exposed SDK methods.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  [system-config resolve reject]
  (if (lib.error/error? system-config)
    (reject system-config)
    (-&gt; system-config
        ;; TEMP
        (dissoc :client/ipfs)
        (lib.integrant/init resolve reject))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Clean-up resources used by the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt!
  [sys-map]
  (ig/halt! sys-map))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
