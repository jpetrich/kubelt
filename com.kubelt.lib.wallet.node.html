<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.lib.wallet.node</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>The Node.js implementation of a crypto wallet wrapper.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.wallet.node
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:refer-clojure :exclude [import])
  (:require
   [&quot;fs&quot; :refer [promises] :rename {promises fs-promises} :as fs]
   [&quot;path&quot; :as path])
  (:require
   [&quot;@ethersproject/wallet&quot; :refer [Wallet]])
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.io.node :as lib.io]
   [com.kubelt.lib.path :as lib.path]
   [com.kubelt.lib.promise :as lib.promise]
   [com.kubelt.lib.wallet.shared :as lib.wallet]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the path to a wallet given the owning application name and wallet name.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- name-&gt;path
  [app-name wallet-name]
  (let [wallet-path (lib.io/kubelt-dir app-name &quot;wallets&quot;)
        wallet-path (.join path wallet-path wallet-name)]
    wallet-path))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the named wallet has the correct permissions, false otherwise.</p><p>Unused predicate</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- valid-perms?
  [app-name wallet-name]
  (let [read-ok (.. fs -constants -R_OK)
        write-ok (.. fs -constants -W_OK)
        perms (bit-or read-ok write-ok)
        wallet-path (name-&gt;path app-name wallet-name)]
    (try
      (.accessSync fs wallet-path read-ok)
      (catch js/Error e
        false))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the named wallet already exists. Throws exception if wallet doesn't exist with this name</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn ensure-wallet&amp;
  [app-name wallet-name]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (lib.io/ensure-kubelt-dir&amp; app-name &quot;wallets&quot;)
         (lib.promise/then
          (fn [_]
            (-&gt; (lib.io/fs-exists?&amp; (name-&gt;path app-name wallet-name))
                (lib.promise/then
                 (fn [x]
                   (if x
                     (resolve x)
                     (reject (lib.error/error (str &quot;no wallet with this name: &quot; wallet-name)))))))))
         (lib.promise/catch reject)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>TODO allow wallet re-creation from mnemonicTODO allow wallet listingTODO allow wallet deletion
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return wallet file path if the named wallet already exists. Returns nil if no wallet exists</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn has-wallet?&amp;
  [app-name wallet-name]
  (lib.io/fs-exists?&amp; (name-&gt;path app-name wallet-name)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the wallet can be successfully decrypted with the supplied password, and false otherwise. Throws exception if password is incorrect</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn can-decrypt?&amp;
  [app-name wallet-name password]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (ensure-wallet&amp; app-name wallet-name)
         (lib.promise/then
          (fn [wallet-path]
            (-&gt;
             (.readFile fs-promises wallet-path)
             (lib.promise/then #(.fromEncryptedJson Wallet % password))
             (lib.promise/then (fn [_] (resolve true)))
             (lib.promise/catch (fn [_] (reject (lib.error/error (str &quot;password for '&quot; wallet-name &quot;' is incorrect&quot;))))))))
         (lib.promise/catch reject)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Create and store an encrypted wallet. The encrypted wallet file is stored in an XDG compliant location based on the application name. It is also named using the supplied wallet name and encrypted with the supplied password. A map describing the created wallet is returned if successful. An error map is returned otherwise. Throws exception on wallet-encryption or fs-write problems</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init&amp;
  [app-name wallet-name password]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (lib.io/ensure-kubelt-dir&amp; app-name &quot;wallets&quot;)
         (lib.promise/then
          (fn [wallet-dirp]
            (-&gt; (has-wallet?&amp; app-name wallet-name)
                (lib.promise/then
                 (fn [file]
                   (when file
                     (reject (lib.error/error (str &quot;wallet &quot; wallet-name &quot; already exists&quot;))))
                   (let [wallet-path (.join path wallet-dirp wallet-name)
                         eth-wallet (.createRandom Wallet)
                         mnemonic (.-mnemonic eth-wallet)]
                     (-&gt; (.encrypt eth-wallet password)
                         (lib.promise/then #(.writeFile fs-promises wallet-path %))
                         (lib.promise/then (fn []
                                             (resolve
                                              (let [{:keys [phrase path locale]} (js-&gt;clj mnemonic :keywordize-keys true)]
                                                {:wallet/path            wallet-path
                                                 :wallet/name            wallet-name
                                                 :wallet.mnemonic/phrase phrase
                                                 :wallet.mnemonic/path   path
                                                 :wallet.mnemonic/locale locale}))))
                         (lib.promise/catch (fn [e] (reject (lib.error/error e)))))))))))
         (lib.promise/catch reject)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a promise that resolves to a wallet map, or that rejects with an error map if a problem occurs.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn load&amp;
  [app-name wallet-name password]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (ensure-wallet&amp; app-name wallet-name)
         (lib.promise/then
          (fn [wallet-path]
            (-&gt; (.readFile fs-promises wallet-path &quot;utf8&quot;)
                (lib.promise/then
                 (fn [wallet-str]
                   (let [eth-wallet (.fromEncryptedJsonSync Wallet wallet-str password)
                         address (.-address eth-wallet)
                         sign-fn (lib.wallet/make-sign-fn eth-wallet)]
                     (resolve
                      {:com.kubelt/type :kubelt.type/wallet
                       :wallet/address address
                       :wallet/sign-fn sign-fn}))))
                (lib.promise/catch
                 (fn [error]
                   (reject (lib.error/error error)))))))
         (lib.promise/catch reject)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a list of wallet names.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn ls&amp;
  [app-name]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (lib.io/ensure-kubelt-dir&amp; app-name &quot;wallets&quot;)
         (lib.promise/then #(resolve (js-&gt;clj (.readdir fs-promises %))))
         (lib.promise/catch reject)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Delete a wallet.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn delete!&amp;
  [app-name wallet-name]
  (let [wallet-path (name-&gt;path app-name wallet-name)]
    (.unlink fs-promises wallet-path)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn create
  []
  :fixme
  ;; (&lt;! (lib.wallet/random-wallet))
  #_(let [sign-fn (lib.wallet/make-sign-fn eth-wallet)]
      {:wallet/address :fixme
       :wallet/sign-fn sign-fn}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Import a wallet and store it encrypted. Returns a promise that resolves to the path to the imported wallet, or if an error occurs rejects with a standard error map. Throws encrypt or fs-wallet exceptions</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn import&amp;
  [app-name wallet-name mnemonic password]
  (lib.promise/promise
   (fn [resolve reject]
     ;; The wallet with the given name doesn't yet exist, we can import
     ;; from the mnemonic and create a wallet with that name.
     (letfn [;; Returns a promise that resolves to the wallet
             ;; JSON. Throws if the mnemonic is invalid.
             (from-mnemonic [mnemonic]
               (try
                 (let [w (.fromMnemonic Wallet mnemonic)]
                   ;; Returns a promise.
                   (.encrypt w password))
                 (catch js/Error e
                   (let [error (lib.error/from-obj e)]
                     (reject error)))))
             ;; Returns the path of the wallet file to write.
             (wallet-path []
               (-&gt; (lib.io/ensure-kubelt-dir&amp; app-name &quot;wallets&quot;)
                   (lib.promise/then #(.join path % wallet-name))))]
       (let [path&amp; (wallet-path)
             wallet&amp; (from-mnemonic mnemonic)]
         (-&gt; (has-wallet?&amp; app-name wallet-name)
             (lib.promise/then
              (fn [wallet]
                (when wallet (reject (lib.error/error (str &quot;wallet &quot; wallet-name &quot; already exists&quot;))))
                (-&gt; (lib.promise/all [path&amp; wallet&amp;])
                    (lib.promise/then
                     (fn [[wallet-dirp wallet-js]]
                       (-&gt; (.writeFile fs-promises wallet-dirp wallet-js)
                           (lib.promise/then (fn [_] (resolve {:wallet/name wallet-name})))
                           (lib.promise/catch (fn [e] (reject (lib.error/from-obj e)))))))
                    (lib.promise/catch (fn [e] (reject (lib.error/from-obj e)))))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
