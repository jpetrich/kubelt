<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">init.cljc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>SDK implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.init
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [integrant.core :as ig]
   [taoensso.timbre :as log])
  (:require
   [com.kubelt.ipfs.client :as ipfs.client]
   [com.kubelt.lib.jwt :as lib.jwt]
   [com.kubelt.lib.multiaddr :as lib.multiaddr]
   [com.kubelt.lib.util :as util]
   [com.kubelt.lib.vault :as lib.vault]
   [com.kubelt.lib.wallet :as lib.wallet]
   [com.kubelt.proto.http :as proto.http])
  (:require
   #?@(:browser [[com.kubelt.lib.http.browser :as http.browser]]
       :node [[com.kubelt.lib.http.node :as http.node]]
       :clj [[com.kubelt.lib.http.jvm :as http.jvm]])))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>System</h2>For each key in the system map, if a corresponding method isimplemented for the ig/init-key multimethod it will be invoked inorder to initialize that part of the system. The return value isstored as part of the system configuration map. Initialization isperformed recursively, making it possible to have nested subsystems.<p>If methods are defined for the ig/halt-key! multimethod, they are invoked in order to tear down the system in the reverse order in which it was initialized.</p><p>To begin the system:   (integrant.core/init) To stop the system:   (integrant.core/halt!)</p><p>Cf. https://github.com/weavejester/integrant.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def system
  {;; These empty defaults should be overridden from the SDK init
   ;; options map.
   :log/level nil
   :ipfs.read/multiaddr nil
   :ipfs.read/scheme nil
   :ipfs.write/multiaddr nil
   :ipfs.write/scheme nil
   :p2p/scheme nil
   :p2p/multiaddr nil
   ;; Our common HTTP client.
   :client/http {}
   ;; Our connection to IPFS.
   :client/ipfs {:ipfs/read {:http/scheme (ig/ref :ipfs.read/scheme)
                             :ipfs/multiaddr (ig/ref :ipfs.read/multiaddr)}
                 :ipfs/write {:http/scheme (ig/ref :ipfs.write/scheme)
                              :ipfs/multiaddr (ig/ref :ipfs.write/multiaddr)}
                 :client/http (ig/ref :client/http)}
   ;; Our connection to the Kubelt p2p system.
   :client/p2p {:http/scheme (ig/ref :p2p/scheme)
                :p2p/multiaddr (ig/ref :p2p/multiaddr)}
   ;; A map from scope identifier to session token (JWT). Upon
   ;; successfully authenticating against a core, the returned session
   ;; token is kept here.
   :crypto/session {}
   ;; The current &quot;wallet&quot; implementation. This is provided externally
   ;; by the user.
   ;; TODO provide no-op wallet implementation, or try to detect wallet
   ;; in the environment, e.g. metamask in browser.
   :crypto/wallet {}})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:log/level</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :log/level [_ min-level]
  ;; Initialize the logging system.
  (when min-level
    (log/merge-config! {:min-level min-level}))
  min-level)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/read-addr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/multiaddr [_ address]
  ;; Return the multiaddress string.
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/read-scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/write-addr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/multiaddr [_ address]
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/write-scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/multiaddr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/multiaddr [_ address]
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/http</h2>TODO support custom user agent string.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/http [_ value]
  {:post [(not (nil? %))]}
  (log/debug {:log/msg &quot;init HTTP client&quot;})
  #?(:browser (http.browser/-&gt;HttpClient)
     :node (http.node/-&gt;HttpClient)
     :clj (http.jvm/-&gt;HttpClient)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/http [_ client]
  {:pre [(satisfies? proto.http/HttpClient client)]}
  (log/debug {:log/msg &quot;halt HTTP client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/ipfs</h2>Send headers with each request: token "xyzabc123" authorization (str "Bearer " token) user-agent "X-Kubelt" headers {:headers {:authorization authorization<pre><code>                :user-agent user-agent}}</code></pre>Use an http.Agent (node-only) to control client behavior:  agent {:agent (.. http Agent.)}
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/ipfs [_ value]
  (let [;; Supply the address of the IPFS node(s). Read and write can
        ;; use different paths if desired, e.g. when you want to read
        ;; from a local daemon but write to a remote service for
        ;; pinning.
        read-addr (get-in value [:ipfs/read :ipfs/multiaddr])
        read-map (lib.multiaddr/str-&gt;map read-addr)
        read-host (:address/host read-map)
        read-port (:address/port read-map)
        read-scheme (get-in value [:ipfs/read :http/scheme])
        write-addr (get-in value [:ipfs/write :ipfs/multiaddr])
        write-map (lib.multiaddr/str-&gt;map write-addr)
        write-host (:address/host write-map)
        write-port (:address/port write-map)
        write-scheme (get-in value [:ipfs/write :http/scheme])
        ;; Get the platform-specific HTTP client.
        http-client (get value :client/http)]
    (let [ipfs-read (str (name read-scheme) &quot;://&quot; read-addr)
          ipfs-write (str (name write-scheme) &quot;://&quot; write-addr)]
      (log/debug {:log/msg &quot;init IPFS client&quot; :ipfs/read ipfs-read :ipfs/write ipfs-write}))
    (try
      ;; Create the options object we pass to client creation fn.
      (let [options {:http/client http-client
                     :read/scheme read-scheme
                     :read/host read-host
                     :read/port read-port
                     :write/scheme write-scheme
                     :write/host write-host
                     :write/port write-port
                     ;; Set a global timeout for *all* requests:
                     ;;:client/timeout 5000
                     }]
        (ipfs.client/init options))
      (catch js/Error e
        (log/fatal e))
      (catch :default e
        (log/error {:log/msg &quot;unexpected error&quot; :error/value e})))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/ipfs [_ client]
  (log/debug {:log/msg &quot;halt IPFS client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/p2p</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/p2p [_ {:keys [http/scheme p2p/multiaddr] :as value}]
  ;; If we wanted to initialize a stateful client for the p2p system,
  ;; this would be the place. Since that system exposes a stateless HTTP
  ;; API, we'll just convert the multiaddresses we're given for the p2p
  ;; read/write nodes into more conventional coordinates (host, port) in
  ;; the system configuration map and pull them out when we need to make
  ;; a call.
  (let [p2p-addr (str (name scheme) &quot;://&quot; multiaddr)]
    (log/debug {:log/msg &quot;init p2p client&quot; :p2p/address p2p-addr}))
  (let [;; Get the multiaddr string and convert into a map
        ;; containing {:address/host :address/port}.
        address (lib.multiaddr/str-&gt;map multiaddr)
        host (get address :address/host)
        port (get address :address/port)]
    (-&gt; value
        (assoc :http/scheme scheme)
        (assoc :http/host host)
        (assoc :http/port port))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/p2p [_ value]
  (log/debug {:log/msg &quot;halt p2p client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/session</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/session [_ tokens]
  (log/debug {:log/msg &quot;init session&quot;})
  ;; If any JWTs are provided, parse them and store the decoded result.
  (let [tokens (reduce (fn [m [core token]]
                         (let [decoded (lib.jwt/decode token)]
                           (assoc m core decoded)))
                       {}
                       tokens)]
    ;; Our session storage map is a &quot;vault&quot;.
    {:com.kubelt/type :kubelt.type/vault
     :vault/tokens tokens}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/session [_ session]
  (log/debug {:log/msg &quot;halt session&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/wallet</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;init wallet&quot;})
  ;; If user provided a wallet, use it if it is valid. Otherwise, return
  ;; a placeholder wallet that will need to be replaced.
  (if-not (lib.wallet/valid? wallet)
    (throw (ex-info &quot;invalid wallet&quot; wallet))
    wallet))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;halt wallet&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:sys/platform</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO any platform-specific setup.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :sys/platform [_ platform]
  (log/debug {:log/msg &quot;init platform&quot; :sys/platform platform})
  platform)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO any platform-specific teardown.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :sys/platform [_ platform]
  (log/debug {:log/msg &quot;halt platform&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>NB: the configuration map is validated by the exposed SDK methods.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK.</p><p>TODO top-level environment key should be injected into sub-keys that depend on it.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  [options]
  ;; NB: inject supplied configuration into the system map before
  ;; calling ig/init. The updated values will be passed to the system
  ;; init fns.
  (let [;; Use any JWTs supplied as options.
        credentials (get options :credential/jwt {})
        ;; Use the wallet provided by the user, or default to a no-op
        ;; wallet otherwise.
        wallet (or (get options :crypto/wallet)
                   (lib.wallet/no-op))
        ;; Get the address of the IPFS node we talk to.
        ipfs-read-maddr (get options :ipfs.read/multiaddr)
        ipfs-read-scheme (get options :ipfs.read/scheme)
        ipfs-write-maddr (get options :ipfs.write/multiaddr)
        ipfs-write-scheme (get options :ipfs.write/scheme)
        ;; Get the address of the Kubelt gateway we talk to.
        p2p-scheme (get options :p2p/scheme)
        p2p-multiaddr (get options :p2p/multiaddr)
        ;; Get the default minimum log level.
        log-level (get options :log/level)
        ;; Update the system configuration map before initializing the
        ;; system.
        system (-&gt; system
                   (assoc :log/level log-level)
                   (assoc :ipfs.read/multiaddr ipfs-read-maddr)
                   (assoc :ipfs.read/scheme ipfs-read-scheme)
                   (assoc :ipfs.write/multiaddr ipfs-write-maddr)
                   (assoc :ipfs.write/scheme ipfs-write-scheme)
                   (assoc :p2p/scheme p2p-scheme)
                   (assoc :p2p/multiaddr p2p-multiaddr)
                   (assoc :crypto/session credentials)
                   (assoc :crypto/wallet wallet))]
    ;; NB: If we provide an additional collection of keys when calling
    ;; integrant.core/init, only those keys will be initialized.
    ;;
    ;; TODO use this mechanism to selectively initialize the system for
    ;; the current context, i.e. in browser, node cli client, etc.
    (ig/init system)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Clean-up resources used by the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt!
  [sys-map]
  (ig/halt! sys-map))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return an options map that can be used to reinitialize the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn options
  [sys-map]
  (let [ipfs-read-maddr (get sys-map :ipfs.read/multiaddr)
        ipfs-read-scheme (get sys-map :ipfs.read/scheme)
        ipfs-write-maddr (get sys-map :ipfs.write/multiaddr)
        ipfs-write-scheme (get sys-map :ipfs.write/scheme)
        p2p-multiaddr (get sys-map :p2p/multiaddr)
        p2p-scheme (get sys-map :p2p/scheme)
        log-level (get sys-map :log/level)
        ;; TODO rename :crypto/session to :crypto/vault for clarity
        credentials (lib.vault/tokens (:crypto/session sys-map))
        wallet (get sys-map :crypto/wallet)]
    {:log/level log-level
     :ipfs.read/multiaddr ipfs-read-maddr
     :ipfs.read/scheme ipfs-read-scheme
     :ipfs.write/multiaddr ipfs-write-maddr
     :ipfs.write/scheme ipfs-write-scheme
     :p2p/scheme p2p-scheme
     :p2p/multiaddr p2p-multiaddr
     :crypto/wallet wallet
     :credential/jwt credentials}))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
