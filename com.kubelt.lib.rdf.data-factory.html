<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.lib.rdf.data-factory</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Generate RDF/cljs quads from RDF/js data factory instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.rdf.data-factory
  {:copyright &quot;Â©2022 Kubelt, Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [&quot;rdf-data-factory&quot; :refer
    [DataFactory
     RDF.Term
     BlankNode
     DefaultGraph
     Literal
     NamedNode
     Variable
     Quad]])
  (:require
   [clojure.string :as str])
  (:require
   [com.kubelt.lib.rdf.util :as rdf.util]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Predicates</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given a BlankNode instance, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn blank-node?
  [term]
  (and
   (identical? (.-constructor term) BlankNode)
   (= (.-termType &quot;BlankNode&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given a NamedNode instance, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn named-node?
  [term]
  (and
   (identical? (.-constructor term) NamedNode)
   (= (.-termType &quot;NamedNode&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given a Literal instance, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn literal?
  [^Literal term]
  (and
   (identical? (.-constructor term) Literal)
   (= (.-termType term) &quot;Literal&quot;)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given a Variable instance, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn variable?
  [^Variable term]
  (and
   (identical? (.-constructor term) Variable)
   (= (.-termType term) &quot;Variable&quot;)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given a DefaultGraph instance, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn default-graph?
  [^DefaultGraph term]
  (and
   (identical? (.-constructor term) DefaultGraph)
   (= (.-termType term) &quot;DefaultGraph&quot;)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given an rdf-data-factory Quad object.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn quad?
  [^Quad o]
  (and
   ;; Check that object was constructed from Quad.
   (identical? (.-constructor o) Quad)
   ;; Check the the term type has the expected value.
   (= (.-termType &quot;Quad&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given value is an RDF.Term, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn term?
  [^RDF.Term term]
  (and
   (js/Object.hasOwnProperty term &quot;termType&quot;)
   (js/Object.hasOwnProperty term &quot;value&quot;)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given value is a valid RDF/js subject term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn subject-term?
  [^RDF.Term term]
  (or (blank-node? term)
      (named-node? term)
      (variable? term)
      (quad? term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given value is a valid RDF/js predicate term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn predicate-term?
  [^RDF.Term term]
  (or (named-node? term)
      (variable? term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given value is a valid RDF/js object term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn object-term?
  [^RDF.Term term]
  (or (blank-node? term)
      (named-node? term)
      (literal? term)
      (variable? term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if given value is a valid RDF/js graph term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn graph-term?
  [^RDF.Term term]
  ;; a DefaultGraph, NamedNode, BlankNode or Variable
  (or (blank-node? term)
      (named-node? term)
      (variable? term)
      (default-graph? term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Internal</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a RDF/js BlankNode instance to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- blank-node-&gt;value
  [^BlankNode term]
  {:pre [(blank-node? term)]}
  (let [value (.-value term)
        value (rdf.util/remove-blank-prefix value)]
    {:rdf/type :rdf.term/blank-node
     :value value}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js NamedNode instance to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- named-node-&gt;value
  [^NamedNode term]
  {:pre [(named-node? term)]}
  (let [value (.-value term)
        ;; TODO expand namespace; it may be the case that we are given a
        ;; prefixed value where we need to look up the prefix and expand
        ;; it to get a full URI.
        ;;
        ;;[ns s] (str/split value &quot;:&quot;)
        ]
    {:rdf/type :rdf.term/named-node
     :value value}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js Literal instance to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- literal-&gt;value
  [^Literal term]
  {:pre [(literal? term)]}
  (let [value (.-value term)
        datatype (.-datatype term)
        datatype-map (named-node-&gt;value datatype)
        language (.-language term)
        ;; Right now, if language isn't provided, we don't set the
        ;; key. Would it be better to always store language even if as
        ;; blank string?
        language-map (if-not (str/blank? language)
                       {:language language}
                       {})]
    (merge {:rdf/type :rdf.term/literal
            :datatype datatype-map
            :value value}
           language-map)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js Variable instance to RDF/cljs format. Note that the name of the variable is stored without the leading '?'.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- variable-&gt;value
  [^Variable term]
  {:pre [(variable? term)]}
  (let [value (.-value term)
        name (rdf.util/remove-var-prefix value)]
    {:rdf/type :rdf.term/variable
     :value name}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js DefaultGraph instance to RDF/cljs format. The :value key of the returned map is always an empty string.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- default-graph-&gt;value
  [^DefaultGraph term]
  {:pre [(default-graph? term)]}
  {:rdf/type :rdf.term/default-graph
   :value &quot;&quot;})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Forward declaration; necessary because a "subject" term can itself be a Quad.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(declare quad-&gt;value)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Convert an RDF/js 'subject' term instance (one of the RDF.Term types allowed in the subject place of a quad) to RDF/cljs format.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- subject-&gt;value
  [^RDF.Term term]
  {:pre [(subject-term? term)]}
  (condp = (.-termType term)
    &quot;BlankNode&quot; (blank-node-&gt;value term)
    &quot;NamedNode&quot; (named-node-&gt;value term)
    &quot;Variable&quot; (variable-&gt;value term)
    &quot;Quad&quot; (quad-&gt;value term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- predicate-&gt;value
  [^RDF.Term term]
  {:pre [(predicate-term? term)]}
  (condp = (.-termType term)
    &quot;NamedNode&quot; (named-node-&gt;value term)
    &quot;Variable&quot; (variable-&gt;value term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- object-&gt;value
  [^RDF.Term term]
  {:pre [(object-term? term)]}
  (condp = (.-termType term)
    &quot;BlankNode&quot; (blank-node-&gt;value term)
    &quot;NamedNode&quot; (named-node-&gt;value term)
    &quot;Literal&quot; (literal-&gt;value term)
    &quot;Variable&quot; (variable-&gt;value term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- graph-&gt;value
  [^RDF.Term term]
  {:pre [(graph-term? term)]}
  (condp = (.-termType term)
    &quot;BlankNode&quot; (blank-node-&gt;value term)
    &quot;NamedNode&quot; (named-node-&gt;value term)
    &quot;Variable&quot; (variable-&gt;value term)
    &quot;DefaultGraph&quot; (default-graph-&gt;value term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Takes a JavaScript RDF/js Quad instance and converts it into our standard map-based quad representation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- quad-&gt;value
  [^Quad quad]
  {:pre [(quad? quad)]}
  (let [subject (subject-&gt;value (.-subject quad))
        predicate (predicate-&gt;value (.-predicate quad))
        object (object-&gt;value (.-object quad))
        graph (graph-&gt;value (.-graph quad))]
    {:rdf/type :rdf.term/quad
     :rdf.quad/subject subject
     :rdf.quad/predicate predicate
     :rdf.quad/object object
     :rdf.quad/graph graph}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
