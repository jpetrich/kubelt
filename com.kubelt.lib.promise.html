<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.lib.promise</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Promise-related utilities. Wrapper around funcool/promesa lib ... macros cloned</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.promise
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:refer-clojure :exclude [delay promise
                            map
                            let
                            -&gt; -&gt;&gt; as-&gt; do])
  (:require
   [promesa.protocols :as pt]
   [clojure.core :as c]
   [promesa.core :as p]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO support goog.Promise, which is the same as a native promise but can also be cancelled.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns true if the argument is a JavaScript promise, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn promise?
  [x]
  (p/promise? x))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a promise that uses the given resolver function. This function must accept two arguments, a function that may be called to resolve the promise, and a second function that may be called to reject the promise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn promise
  [resolver]
  {:pre [(fn? resolver)]}
  (p/create resolver))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn then
  [promise on-fulfilled]
  {:pre [(fn? on-fulfilled)]}
  (p/then promise on-fulfilled))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn catch
  [promise on-rejected]
  {:pre [(fn? on-rejected)]}
  (p/catch promise on-rejected))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn finally
  [promise on-final]
  {:pre [(fn? on-final)]}
  (p/finally promise on-final))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a promise that resolves to the given value.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn resolved
  [x]
  (p/promise x))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a promise that rejects to the given value.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn rejected
  [x]
  (p/rejected x))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns a cancellable promise that will be fulfilled with this promise's fulfillment value or rejection reason.  However, if this promise is not fulfilled or rejected within <code>ms</code> milliseconds, the returned promise is cancelled with a TimeoutError</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn timeout
  [p ms]
  (p/timeout p ms))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a timeout in miliseconds and optional value, returns a promise that will fulfilled with provided value (or nil) after the time is reached.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn delay
  [ms]
  (p/delay ms))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given an array of promises, return a promise that is fulfilled when first one item in the array is fulfilled.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn any
  [coll]
  (p/any coll))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given an array of promises, return a promise that is fulfilled  when all the items in the array are fulfilled.</p><p>Example:</p><p>(-> (all [(promise :first-promise)           (promise :second-promise)]     (then (fn [[first-result second-result]]))      (println (str first-result ", " second-result)</p><p>Will print out :first-promise, :second-promise.</p><p>If at least one of the promises is rejected, the resulting promise will be rejected.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn all
  [coll]
  (p/all coll))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>cloned of [funcool/promesa 8.0.450]</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmacro let
  [bindings &amp; body]
  `(pt/-bind
    (pt/-promise nil)
    (fn [_#]
      ~(c/-&gt;&gt; (reverse (partition 2 bindings))
              (reduce (fn [acc [l r]]
                        `(pt/-bind (pt/-promise ~r) (fn [~l] ~acc)))
                      `(do! ~@body))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
