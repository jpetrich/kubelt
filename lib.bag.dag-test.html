<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">lib.bag.dag-test</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Test the BAG dag implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns lib.bag.dag-test
  (:require
   [cljs.test :as t :refer [deftest is testing use-fixtures]]
   [clojure.string :as str])
  (:require
   [malli.core :as m]
   [malli.error :as me])
  (:require
   [com.kubelt.lib.bag :as bag]
   [com.kubelt.lib.bag.dag :as bag.dag]
   [com.kubelt.lib.bag.node :as bag.node]
   [com.kubelt.lib.ipld :as ipld]
   [com.kubelt.spec.bag :as spec.bag]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest make-dag-test
  (testing &quot;with defaults&quot;
    (let [dag (bag.dag/make-dag)]
      (is (map? dag))
      (is (m/validate spec.bag/dag dag)
          &quot;the dag conforms to its schema&quot;)
      (is (= ipld/default-codec (:ipld/codec dag))
          &quot;the dag uses the default codec&quot;)
      (is (= ipld/default-hasher (:ipld/hasher dag))
          &quot;the dag uses the default hash&quot;)))
  (testing &quot;sets codec&quot;
    (let [dag (bag.dag/make-dag {:ipld/codec ipld/codec-json})]
      (is (map? dag))
      (is (m/validate spec.bag/dag dag)
          &quot;the dag conforms to its schema&quot;)
      (is (= ipld/codec-json (:ipld/codec dag))
          &quot;the dag uses the specified codec&quot;)
      (is (= ipld/default-hasher (:ipld/hasher dag))
          &quot;the dag uses the same hash as parent bag&quot;)))
  (testing &quot;sets hash&quot;
    (let [dag (bag.dag/make-dag {:ipld/hasher ipld/hasher-blake3-256})]
      (is (map? dag))
      (is (m/validate spec.bag/dag dag)
          &quot;the dag conforms to its schema&quot;)
      (is (= ipld/default-codec (:ipld/codec dag))
          &quot;the dag uses the same codec as parent bag&quot;)
      (is (= ipld/hasher-blake3-256 (:ipld/hasher dag))
          &quot;the dag uses the specified hash&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest has-root?-test
  (testing &quot;new dag has no root node&quot;
    (let [dag (bag.dag/make-dag)]
      (is (not (bag.dag/has-root? dag))
          &quot;a new dag has no root node&quot;)))
  (testing &quot;a dag with a root node&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})
          dag' (bag.dag/add-child dag node)]
      (is (bag.dag/has-root? dag')
          &quot;dag has a root node&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest has-node?-test
  (testing &quot;new dag has no nodes&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})]
      (is (not (bag.dag/has-node? dag node))
          &quot;new dag has no node&quot;)))
  (testing &quot;a root node belongs to a dag&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})
          dag' (bag.dag/add-child dag node)]
      (is (bag.dag/has-node? dag' node)
          &quot;a dag has a root node&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest root-test
  (testing &quot;a new dag has no root node&quot;
    (let [dag (bag.dag/make-dag)]
      (is (nil? (bag.dag/root dag))
          &quot;new dag root is nil&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest children-test
  (testing &quot;node with no children&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})
          dag' (bag.dag/add-child dag node)]
      (is (empty? (bag.dag/children dag' node))
          &quot;there are no children of a leaf node&quot;)))
  (testing &quot;node with a single child&quot;
    (let [dag (bag.dag/make-dag)
          parent (bag.node/make-node {:parent true})
          child (bag.node/make-node {:child true})
          dag' (-&gt; dag
                   (bag.dag/add-child parent)
                   (bag.dag/add-child parent child))]
      (is (empty? (bag.dag/children dag' child))
          &quot;a leaf node has no children&quot;)
      (is (= 1 (count (bag.dag/children dag' parent)))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest leaf?-test
  (testing &quot;a new node is not a leaf&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})]
      (is (bag.dag/leaf? dag node)
          &quot;an un-added node is not a leaf node&quot;)))
  (testing &quot;a root node is a leaf node&quot;
    (let [dag (bag.dag/make-dag)
          node (bag.node/make-node {:foo &quot;bar&quot;})
          dag' (bag.dag/add-child dag node)]
      (is (bag.dag/leaf? dag' node)
          &quot;a single root node is a leaf&quot;)))
  (testing &quot;a root node with child is not a leaf&quot;
    (let [dag (bag.dag/make-dag)
          parent (bag.node/make-node {:parent true})
          child (bag.node/make-node {:child true})
          dag' (-&gt; dag
                   (bag.dag/add-child parent)
                   (bag.dag/add-child parent child))]
      (is (not (bag.dag/leaf? dag' parent))
          &quot;a parent node is not a leaf node&quot;)
      (is (bag.dag/leaf? dag' child)
          &quot;the child node is a leaf node&quot;))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest branch?-test
  (testing 
    ;; TODO))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest node-seq-test
  (testing &quot;empty dag&quot;
    (let [dag (bag.dag/make-dag)
          node-seq (bag.dag/node-seq dag)]
      (is (not (bag.dag/has-root? dag))
          &quot;dag has no root node&quot;)
      (is (nil? node-seq)
          &quot;seq of an empty collection is nil&quot;)
      (is (not (seq? node-seq))
          &quot;returned value is not a seq&quot;)))
  (testing &quot;single node dag&quot;
    (let [dag (bag.dag/make-dag)
          data {:foo &quot;bar&quot;}
          node (bag.node/make-node data)
          dag' (bag.dag/add-child dag node)
          node-seq (bag.dag/node-seq dag')]
      (is (bag.dag/has-root? dag')
          &quot;dag has a root node&quot;)
      (is (seq? node-seq)
          &quot;returned value is a seq&quot;)
      (is (= 1 (count node-seq))
          &quot;seq has a single entry&quot;)
      ;; Compare node data since the node returned as part of the node
      ;; sequence may have been altered via the addition of various
      ;; other attributes, meaning direct equality comparison will fail.
      (let [first-data (:kubelt.node/data (first node-seq))]
        (is (= data first-data)
            &quot;first seq entry is the expected node&quot;))))
  (testing &quot;two node dag&quot;
    (let [dag (bag.dag/make-dag)
          parent (bag.node/make-node {:parent true})
          child (bag.node/make-node {:child true})
          dag' (-&gt; dag
                   (bag.dag/add-child parent)
                   (bag.dag/add-child parent child))
          node-seq (bag.dag/node-seq dag')]
      (is (= 2 (count node-seq))
          &quot;there are two nodes in the sequence&quot;)
      (let [first-node (first node-seq)
            second-node (second node-seq)]
        (is (:parent (:kubelt.node/data first-node)))
        (is (:child (:kubelt.node/data second-node)))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">#_(deftest set-root-test
  (testing &quot;set root node of dag&quot;
    (let [b (bag/make-bag)
          d (bag.dag/make-dag b)
          data {:foo &quot;bar&quot;}
          n (bag.node/make-node d data)
          d' (bag.dag/set-root d n)]
      (is (map? d'))
      (is (m/validate spec.bag/dag d')
          &quot;the dag conforms to its schema&quot;)
      (is (= n (:kubelt.dag/root d'))
          &quot;the dag has the expected root node&quot;))))
(deftest as-tree-test
  (testing 
    (let [dag (bag.dag/make-dag)]
      ;; TODO)))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
