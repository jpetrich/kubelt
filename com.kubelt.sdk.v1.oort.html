<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.sdk.v1.oort</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Account management.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.sdk.v1.oort
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [camel-snake-kebab.core :as csk]
   [camel-snake-kebab.extras :as cske]
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.jwt :as lib.jwt]
   [com.kubelt.lib.oort :as lib.oort]
   [com.kubelt.lib.promise :as lib.promise :refer [promise]]
   [com.kubelt.lib.rpc :as lib.rpc]
   [com.kubelt.lib.vault :as lib.vault]
   [com.kubelt.lib.wallet :as lib.wallet]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>authenticate!</h2>In a browser context, this keypair is managed by an external walletprovider plugin, e.g. MetaMask. On other platforms, similarfunctionality is provided via other means.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Create an account or authorize an existing account. User identity is centered around an wallet accounts and is also the name linked to the user's Kubelt application data (via their private core).</p><p>The public key from the wallet param must be available as a hex-encoded string along with the account id. These two pieces of information together kick off an authentication request.</p><p>The signing function stored in the wallet is used to sign a nonce to complete the auth flow. Returns a promise that resolves to the updated system map containing the JWT for the system wallet core address, or is rejected with some information about the error that occurred.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn authenticate&amp;
  [sys]
  ;; TODO add an extra arity that allows a wallet to be passed in?
  ;; TODO validate system map (especially: ensure wallet is present)
  (let [core (get-in sys [:crypto/wallet :wallet/address])]
    (-&gt; (lib.oort/authenticate! sys)
        (lib.promise/then
         (fn [auth-result]
           (if (lib.error/error? auth-result)
             ;; This triggers .catch handlers on returned promise.
             (throw (ex-info &quot;error&quot; auth-result))
             ;; We successfully retrieved a nonce, now verify it by signing
             ;; it and sending it back.
             auth-result)))
        (lib.promise/then
         (fn [nonce]
           (let [sign-fn (get-in sys [:crypto/wallet :wallet/sign-fn])
                 signature (sign-fn (:message nonce))]
             [nonce signature])))
        (lib.promise/then
         (fn [[nonce signature-p]]
           ;; NB: the signature is expected to be a promise, even if
           ;; not strictly necessary on some platforms.
           (lib.promise/then
            signature-p
            (fn [signature]
              ;; If successful we get back a JWT that needs to be stored
              ;; in the system map. NB: the JWT has an expiry and encodes
              ;; client IP to restrict renewing JWTs for other clients.
              ;; TODO check/assert that this is true.
              (lib.promise/then
               (lib.oort/verify! sys core (:nonce nonce) signature)
               (fn [verify-result]
                 (if (lib.error/error? verify-result)
                   ;; This triggers .catch handlers on returned promise.
                   (throw (ex-info &quot;error&quot; verify-result))
                   ;; We successfully retrieved a nonce, now verify it by signing
                   ;; it and sending it back.
                   (let [decoded-jwt (lib.jwt/decode verify-result)]
                     ;; TODO verify jwt
                     ;; TODO once we are able to inject a
                     ;; platform-specific storage capability, use that
                     ;; to allow the SDK state (or possibly just a
                     ;; subset, e.g. tokens) to be frozen and thawed
                     ;; back out
                     (-&gt; sys
                         (assoc :crypto/session (lib.vault/vault {core decoded-jwt}))
                         (assoc-in [:crypto/session :vault/tokens*]  {core verify-result})))))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Create an account from a JavaScript context.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn authenticate-js!
  [sys core]
  (authenticate&amp; sys))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO test me</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn rpc-api [sys core]
  (lib.oort/rpc-api sys core))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn rpc-api-js [sys core]
  (rpc-api sys core))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn claims&amp; [sys core]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (rpc-api sys core)
         (lib.promise/then
          (fn [api]
            (-&gt; (lib.rpc/rpc-call&amp; sys api {:method [:kb :get-core-claims] :args []})
                (lib.promise/then
                 (fn [x]
                   (if-let [error (-&gt; x :http/body :error)]
                     (reject error)
                     (resolve (-&gt; x :http/body :result))))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn claims-js [sys]
  (-&gt; (claims&amp; sys (get-in sys [:crypto/wallet :wallet/address]))
      (lib.promise/then clj-&gt;js)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO test me</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn call-rpc&amp; [sys core method params]
  (lib.promise/promise
   (fn [resolve reject]
     (-&gt; (rpc-api sys core)
         (lib.promise/then
          (fn [api]
            (-&gt; (lib.rpc/rpc-call&amp; sys api {:method method :params params})
                (lib.promise/then resolve)
                (lib.promise/catch
                 (fn [e]
                   (reject
                    (lib.error/from-obj e)))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>entrypoint that uses sdk-rpc-client and sdk-rpc-api</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn call-rpc-js
  ([sys args]
   (let [{:keys [method params]} (js-&gt;clj args :keywordize-keys true)]
     (-&gt; (call-rpc&amp; sys
                    (-&gt; sys :crypto/wallet :wallet/address)
                    (mapv keyword (js-&gt;clj method))
                    params)
         (lib.promise/then #(clj-&gt;js (cske/transform-keys csk/-&gt;camelCaseString %)))
         (lib.promise/catch clj-&gt;js))))
  ([sys method params]
   (let [method (mapv keyword (js-&gt;clj method))
         params (js-&gt;clj params :keywordize-keys true)]
     (-&gt; (call-rpc&amp; sys (-&gt; sys :crypto/wallet :wallet/address) method params)
         (lib.promise/then #(clj-&gt;js (cske/transform-keys csk/-&gt;camelCaseString %)))
         (lib.promise/catch clj-&gt;js)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>logged-in?</h2>A predicate that returns true when the user has successfully authenticated.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO check for valid sys map.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn logged-in?
  [sys core]
  (let [session-tokens (get-in sys [:crypto/session :vault/tokens])]
    ;; TODO validate the JWT using the current wallet
    (contains? session-tokens core)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn logged-in-js?
  [sys core]
  (promise
   (fn [resolve reject]
     (resolve (logged-in? sys core)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>set-wallet</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn set-wallet
  [sys wallet]
  (lib.promise/promise
   (fn [resolve reject]
     (if-not (lib.wallet/valid? wallet)
       (reject (lib.wallet/explain wallet))
       (let [sys' (assoc sys :crypto/wallet wallet)]
         (resolve sys'))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn set-wallet-js
  [sys wallet]
  (let [wallet-map (lib.wallet/to-edn wallet)]
    (set-wallet sys wallet-map)))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
