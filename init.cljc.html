<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">init.cljc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>SDK implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.init
  {:copyright &quot;Â©2022 Kubelt, Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [integrant.core :as ig]
   [taoensso.timbre :as log])
  (:require
   [com.kubelt.ipfs.client :as ipfs.client]
   [com.kubelt.lib.detect :as detect]
   [com.kubelt.lib.multiaddr :as lib.multiaddr]
   [com.kubelt.lib.util :as util]
   [com.kubelt.lib.wallet :as lib.wallet]
   [com.kubelt.proto.http :as proto.http])
  (:require
   #?@(:browser [[com.kubelt.lib.http.browser :as http.browser]]
       :node [[com.kubelt.lib.http.node :as http.node]]
       :clj [[com.kubelt.lib.http.jvm :as http.jvm]])))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>System</h2>For each key in the system map, if a corresponding method isimplemented for the ig/init-key multimethod it will be invoked inorder to initialize that part of the system. The return value isstored as part of the system configuration map. Initialization isperformed recursively, making it possible to have nested subsystems.<p>If methods are defined for the ig/halt-key! multimethod, they are invoked in order to tear down the system in the reverse order in which it was initialized.</p><p>To begin the system:   (integrant.core/init) To stop the system:   (integrant.core/halt!)</p><p>Cf. https://github.com/weavejester/integrant.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def system
  {;; Our connection to IPFS.
   :client/ipfs {:ipfs/multiaddr &quot;/ip4/127.0.0.1/tcp/5001&quot;
                 :client/http {}}
   ;; Our connection to the Kubelt p2p system. Typically write paths
   ;; will go through a kubelt managed http gateway.
   :client/p2p {:p2p/read {:http/scheme :http
                           :http/address &quot;/ip4/127.0.0.1/tcp/9061&quot;}
                :p2p/write {:http/scheme :http
                            :http/address &quot;/ip4/127.0.0.1/tcp/9061&quot;}}
   ;; A map from scope identifier to session token (JWT). Upon
   ;; successfully authenticating against a core, the returned session
   ;; token is kept here.
   :crypto/session {}
   ;; The current &quot;wallet&quot; implementation. This is provided externally
   ;; by the user.
   ;; TODO provide no-op wallet implementation, or try to detect wallet
   ;; in the environment, e.g. metamask in browser.
   :crypto/wallet {}})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/ipfs</h2>Send headers with each request: token "xyzabc123" authorization (str "Bearer " token) user-agent "X-Kubelt" headers {:headers {:authorization authorization<pre><code>                :user-agent user-agent}}</code></pre>Use an http.Agent (node-only) to control client behavior:  agent {:agent (.. http Agent.)}
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/ipfs [_ value]
  (let [;; Set a global timeout for *all* requests:
        timeout {:timeout &quot;2m&quot;}
        ;; Supply the address of the IPFS node:
        maddr-str (get value :ipfs/multiaddr)
        url {:url maddr-str}
        ;; Create the options object we pass to client creation fn.
        options (clj-&gt;js (merge url timeout))
        ;; Get the platform-specific HTTP client.
        http-client (get value :client/http)]
    (log/debug {:log/msg &quot;init IPFS client&quot; :ipfs/addr maddr-str})
    (try
      (let [;; TODO convert multiaddress to URL parts and pass in
            ;; options map to IPFS client.
            ;; http-scheme &quot;&quot;
            ;; http-host &quot;&quot;
            ;; http-port &quot;&quot;
            ;; options {:http/scheme http-scheme
            ;;          :http/host http-host
            ;;          :http/port http-port}
            options {:http/client http-client}]
        ;;(.create ipfs-http-client options)
        (ipfs.client/init options))
      (catch js/Error e
        (log/fatal e))
      (catch :default e
        (log/error {:log/msg &quot;unexpected error&quot; :error/value e})))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/ipfs [_ client]
  (log/debug {:log/msg &quot;halt IPFS client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/p2p</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/p2p [_ {:keys [p2p/read p2p/write] :as value}]
  ;; If we wanted to initialize a stateful client for the p2p system,
  ;; this would be the place. Since that system exposes a stateless HTTP
  ;; API, we'll just convert the multiaddresses we're given for the p2p
  ;; read/write nodes into more conventional coordinates (host, port) in
  ;; the system configuration map and pull them out when we need to make
  ;; a call.
  (let [;; read; get the multiaddr string and convert into a map
        ;; containing {:address/host :address/port}.
        read-maddr (get read :http/address)
        read-scheme (get read :http/scheme)
        read-address (-&gt; read-maddr
                         lib.multiaddr/str-&gt;map
                         (assoc :http/scheme read-scheme))
        ;; write
        write-maddr (get write :http/address)
        write-scheme (get write :http/scheme)
        write-address (-&gt; write-maddr
                          lib.multiaddr/str-&gt;map
                          (assoc :http/scheme write-scheme))
        ;; Format log messages.
        log-read (str (name read-scheme) &quot;::&quot; read-maddr)
        log-write (str (name write-scheme) &quot;::&quot; write-maddr)]
    (log/debug {:log/msg &quot;init p2p client&quot; :read/addr log-read :write/addr log-write})
    (-&gt; value
        (assoc :p2p/read read-address)
        (assoc :p2p/write write-address))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/p2p [_ value]
  (log/debug {:log/msg &quot;halt p2p client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/http</h2>TODO if possible, we want that when compiling an environment-specificvariant of the SDK that we are optimizing away whichever of theseHttpClient protocol reifications isn't used.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>We expect the value to be a keyword naming the execution environment that we are initializing for.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/http [_ env]
  {:post [(not (nil? %))]}
  (log/debug {:log/msg &quot;init HTTP client [&quot; env &quot;]&quot;})
  #?(:browser (http.browser/-&gt;HttpClient)
     :node (http.node/-&gt;HttpClient)
     :clj (http.jvm/-&gt;HttpClient))
  #_(condp = env
    :platform.type/browser (http.browser/-&gt;HttpClient)
    ;;:platform.type/jvm (http.jvm/-&gt;HttpClient)
    :platform.type/node (http.node/-&gt;HttpClient)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/http [_ client]
  {:pre [(satisfies? proto.http/HttpClient client)]}
  (log/debug {:log/msg &quot;halt HTTP client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/session</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/session [_ env]
  (log/debug {:log/msg &quot;init session&quot;})
  ;; Our session storage map is a &quot;vault&quot;.
  {:com.kubelt/type :kubelt.type/vault
   :vault/tokens {}})</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/session [_ session]
  (log/debug {:log/msg &quot;halt session&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/wallet</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;init wallet&quot;})
  ;; If user provided a wallet, use it if it is valid. Otherwise, return
  ;; a placeholder wallet that will need to be replaced.
  (if-not (lib.wallet/valid? wallet)
    (throw (ex-info &quot;invalid wallet&quot; wallet))
    wallet))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;halt wallet&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:sys/platform</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO any platform-specific setup.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :sys/platform [_ platform]
  (log/debug {:log/msg &quot;init platform&quot; :sys/platform platform})
  platform)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO any platform-specific teardown.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :sys/platform [_ platform]
  (log/debug {:log/msg &quot;halt platform&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>NB: the configuration map is validated by the exposed SDK methods.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK.</p><p>TODO top-level environment key should be injected into sub-keys that depend on it.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  [{:keys [logging/min-level] :as options}]
  ;; Initialize the logging system.
  (when min-level
    (log/merge-config! {:min-level min-level}))
  ;; NB: inject supplied configuration into the system map before
  ;; calling ig/init. The updated values will be passed to the system
  ;; init fns.
  (let [;; Initialize for given platform if specified by user, or detect
        ;; the current platform and initialize accordingly, otherwise.
        platform (or (get options :sys/platform)
                     (util/platform))
        ;; Use the wallet provided by the user, or default to a no-op
        ;; wallet otherwise.
        wallet (or (get options :crypto/wallet)
                   (lib.wallet/no-op))
        ;; Get p2p connection addresses determined by whether or not we
        ;; can detect a locally-running p2p node.
        default (:client/p2p system)
        p2p-options (detect/node-or-gateway default options)
        ;; Update the system configuration map before initializing the
        ;; system.
        system (-&gt; system
                   (assoc :sys/platform platform)
                   (assoc :crypto/wallet wallet)
                   (assoc :client/http platform)
                   (assoc :client/p2p p2p-options))]
    ;; NB: If we provide an additional collection of keys when calling
    ;; integrant.core/init, only those keys will be initialized.
    ;;
    ;; TODO use this mechanism to selectively initialize the system for
    ;; the current context, i.e. in browser, node cli client, etc.
    (ig/init system)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Clean-up resources used by the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt!
  [sys-map]
  (ig/halt! sys-map))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
