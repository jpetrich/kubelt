<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.sdk.v1</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Defines the interface of the Kubelt SDK, v1.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.sdk.v1
  {:copyright &quot;Â©2022 Proof Zero Inc&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [malli.core :as m]
   [malli.error :as me])
  (:require
   [com.kubelt.lib.config :as lib.config]
   [com.kubelt.lib.config.default :as lib.config.default]
   [com.kubelt.lib.config.sdk :as lib.config.sdk]
   [com.kubelt.lib.config.system :as lib.config.system]
   [com.kubelt.lib.error :as lib.error :refer [conform*] :refer-macros [conform*]]
   [com.kubelt.lib.init :as lib.init]
   [com.kubelt.lib.promise :as lib.promise :refer [promise?]]
   [com.kubelt.spec.config :as spec.config])
  (:require-macros
   [com.kubelt.spec :as kspec]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>All of the namespaces under sdk.v1 expose interface functions, and don't implement any business logic. Instead, they call methods under sdk.impl to do their work.</p><p>The methods exposed as part of the SDK API must all:</p><ul><li>use (malli) schemas to check inputs and outputs</li><li>work with inputs provided as either JavaScript or ClojureScript  data</li><li>generate outputs in a suitable format for the caller's execution  context, i.e. JavaScript or ClojureScript</li></ul>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>init</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK. Accepts an optional configuration map and returns an SDK instance.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  ;; The 0-arity implementation uses the default configuration.
  ([]
   {:post (promise? %)}
   (init {}))
  ;; The 1-arity implementation expects a configuration map.
  ([config]
   {:pre [(map? config)] :post [(promise? %)]}
   ;; Check that the user-provided options map is valid. If not, an
   ;; error map is returned. Note that these configuration options are
   ;; not required, so we provide defaults for those values that aren't
   ;; provided.
   (let [system-config (lib.config.system/config-&gt;system config)]
     (lib.promise/promise
      (fn [resolve reject]
        (lib.init/init system-config resolve reject))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK from JavaScript context. Accepts an optional configuration map and returns an SDK instance.</p><p>We deliberately resolve a ClojureScript data structure, without converting to a JavaScript object. The returned system description is intended to be an opaque handle, not something to be interacted with from the calling context.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init-js
  ;; The 0-arity implementation uses the default configuration.
  ([]
   {:post [(promise? %)]}
   (init-js #js{}))
  ;; The 1-arity implementation uses expects a configuration object.
  ([config]
   {:pre [(object? config)] :post [(promise? %)]}
   (let [config (lib.config/obj-&gt;map config)]
     (-&gt; (init config)
         ;; If an error occurred, convert the returned error map into an
         ;; JavaScript object.
         (lib.promise/catch
          (fn [e]
            (lib.promise/rejected (clj-&gt;js e))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>halt</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Shutdown the SDK. Takes the system description returned by calling (init) as the system to halt. Returns a promise/future that resolves when the shutdown is complete, or rejects with an error map describing the problem that occurred.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt!
  [system]
  {:pre [(map? system)]}
  (lib.promise/promise
   (fn [resolve reject]
     (let [result (lib.init/halt! system)]
       (if-not (lib.error/error? result)
         (resolve result)
         (reject result))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Shutdown the SDK from a JavaScript context. Takes the system description returned by calling (init) as the system to halt.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt-js!
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  (-&gt; (halt! system)
      (lib.promise/catch
          (fn [e]
            (clj-&gt;js e)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>options</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the options map representing the SDK state, allowing for the SDK to be re-instantiated.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn options
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  (lib.promise/promise
   (fn [resolve reject]
     (let [result (lib.config.sdk/options system)]
       (if-not (lib.error/error? result)
         (resolve result)
         (reject result))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return an options object for the SDK from a JavaScript context.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn options-js
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  (-&gt; (options system)
      (lib.promise/then
       (fn [m]
         (clj-&gt;js m)))
      (lib.promise/catch
          (fn [e]
            (clj-&gt;js e)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>store</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Store the state of the system using the platform storage capability that was injected (or provided by default) during SDK initialization. We only care about preserving state that can't be recreated or are costly to recreate, e.g. JWTs. Returns a promise that resolves to a map of the stored state once complete.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn store&amp;
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  (let [;; We'll store the options that were used to initialize the SDK
        ;; so we can reinitialize a new instance.
        init-options&amp; (options system)
        ;; This function provides a platform specific means of storing
        ;; a (small) data map.
        store-fn (get-in system [:config/storage :storage/store-fn])
        ;; Get the JWTs currently owned by the SDK instance.
        vault (get system :crypto/session)]
    ;; TODO move into library utility.
    (-&gt; init-options&amp;
        (lib.promise/then
         (fn [options]
           ;; Construct the state map to store.
           (let [;; options can't include fns if we are to serialize it!
                 options (-&gt; options
                             (dissoc :config/storage)
                             (dissoc :crypto/wallet))
                 state {:options options :vault vault}]
             ;; Returns a promise that resolves when the writing is
             ;; finished.
             (store-fn state)))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Store the state of the system in a platform-specific way.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn store-js&amp;
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  ;; We don't have any arguments to convert from JSON to edn, so we just
  ;; invoke store&amp; directly.
  (store&amp; system))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>restore</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn restore&amp;
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  (let [;; This function provides a platform specific means of restoring
        ;; a (small) data map.
        restore-fn (get-in system [:config/storage :storage/restore-fn])
        ;; Resolves to the data that has been restored.
        restore&amp; (restore-fn)]
    (-&gt; restore&amp;
        (lib.promise/then
         (fn [{:keys [options vault]}]
           ;; TODO fold options back into system map?
           (let [restored-system (-&gt; system
                                     (assoc :crypto/session vault
                                            :crypto/wallet {:com.kubelt/type :kubelt.type/wallet
                                                            :wallet/address (-&gt; vault :vault/tokens keys first)}))]
             (conform* [spec.config/restored-system restored-system]
                       restored-system)))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a system map that has had saved state restored.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn restore-js&amp;
  [system]
  {:pre [(map? system)] :post [(promise? %)]}
  ;; We don't have any arguments to convert from JSON to edn, so we just
  ;; invoke restore&amp; directly.
  (restore&amp; system))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
