<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.rpc.schema.parse</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Parse an OpenRPC schema.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc.schema.parse
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.rpc.schema.expand :as rpc.schema.expand]
   [com.kubelt.rpc.schema.util :as rpc.schema.util]
   [com.kubelt.rpc.schema.validate :as rpc.schema.validate]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO consider malli transformers for JSON to edn transformation</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO make private</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn schema-&gt;version
  [schema]
  {:pre [(map? schema)]}
  (get schema :openrpc))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO make private</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn schema-&gt;metadata
  [schema]
  {:pre [(map? schema)]}
  (get schema :info))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO make private</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn schema-&gt;servers
  [schema]
  {:pre [(map? schema)]}
  (get schema :servers []))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method map, return a vector of all parameter names after keywordization.</p><p>TODO make private</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn params-all
  [{:keys [params] :as method}]
  {:pre [(map? method)]}
  (reduce (fn [a {param-name :name}]
            (let [param-kw (rpc.schema.util/s-&gt;kw param-name)]
              (conj a param-kw)))
          [] params))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a map describing a parameter, return true if the parameter is marked as being required, and false if the parameter is optional. A required parameter is one that has the :required key with a value of true. By default parameters are not required.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn param-required?
  [param]
  (= true (get param :required false)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method map, return a vector of keywordized parameter names for just those parameters that are required.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn params-required
  [{:keys [params] :as method}]
  {:pre [(map? method)]}
  (reduce (fn [a {param-name :name :as param}]
            (if (param-required? param)
              (conj a (rpc.schema.util/s-&gt;kw param-name))
              a))
          [] params))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method map, return a vector of keywordized parameter names for just those parameters that are optional.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn params-optional
  [{:keys [params] :as method}]
  {:pre [(map? method)]}
  (reduce (fn [a {param-name :name :as param}]
            (if-not (param-required? param)
              (conj a (rpc.schema.util/s-&gt;kw param-name))
              a))
          [] params))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method map, return a map of the parameters of the RPC call. The keys of the map are keywordized versions of the string parameter name, and the values are maps describing the parameter.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn method-&gt;params
  [{:keys [params] :as method}]
  {:pre [(map? method)]}
  (reduce (fn [m {param-name :name :as param}]
            (let [param-kw (rpc.schema.util/s-&gt;kw param-name)]
              (assoc m param-kw param)))
          {}
          params))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method, return a map from keywordized parameter name to the schema that may be used to validate the values supplied for that parameter.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn method-&gt;schemas
  [{:keys [params] :as method}]
  {:pre [(map? method)]}
  (into {} (map (fn [{param-name :name schema :schema}]
                  (let [param-kw (rpc.schema.util/s-&gt;kw param-name)]
                    ;; TODO translate schema into malli. For now we just
                    ;; return the supplied JSON Schema.
                    [param-kw schema]))
                params)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Extract the method descriptions from an Open RPC schema supplied as edn. Note that underscores in the method names are used to namespace the methods, i.e. a method named foo_getBar will be mapped into [:foo :get-bar].</p><p>TODO make private</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn schema-&gt;methods
  [schema]
  {:pre [(map? schema)]}
  (letfn [(f [m method]
            (let [method-name (get method :name)
                  method-summary (get method :summary)
                  params-all-kw (params-all method)
                  params-req-kw (params-required method)
                  params-opt-kw (params-optional method)
                  params (method-&gt;params method)
                  schemas (method-&gt;schemas method)
                  ;; result
                  path (rpc.schema.util/name-&gt;path method-name)
                  method {:method/name method-name
                          :method/summary method-summary
                          :method/params params
                          :method.params/all params-all-kw
                          :method.params/required params-req-kw
                          :method.params/optional params-opt-kw
                          :method.params/schemas schemas
                          ;; Include this to see the original schema
                          ;; definition of the method.
                          ;;:method/raw method
                          }]
              (assoc m path method)))]
    (let [methods (get schema :methods [])]
      (reduce f {} methods))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>parse</h2>TODO convert result names to kebab keywordse.g. "hashesPerSecond" -> :hashes-per-second<ul><li>use original string names <em>and</em> kebab keywords</li></ul><p>TODO replace \$ref with the referenced values</p><ul><li>method > params</li><li>method > result</li></ul><p>TODO use error threading fn (error-> ...) that only threads the value through successive steps as long as the return value isn't an error map.</p><p>TODO build (error-> ...) on top of (fn-> x (fn [x] ...)). Applies the function to each return result and if return value is true, continues threading. Cf. some->; use lib.error/error? as fn, e.g. (def error-> x lib.error/error?)</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a provider URL and an OpenRPC schema (converted to edn), transform the schema into a client map. The options map is the same as that provided to the client init function.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn parse
  [schema options]
  {:pre [(map? schema) (map? options)]}
  ;; Check for various common errors that may occur in the schema
  ;; definition.
  (if-let [schema (rpc.schema.validate/validate schema)]
    (if (lib.error/error? schema)
      schema
      ;; If no errors are detected, expand the schema, i.e. replace
      ;; internal references to definitions by the definitions
      ;; themselves.
      (let [schema (rpc.schema.expand/expand schema)
            rpc-version (schema-&gt;version schema)
            rpc-metadata (schema-&gt;metadata schema)
            rpc-servers (schema-&gt;servers schema)
            ;; Generate a map from &quot;path&quot; (a vector of keywords
            ;; representing an available RPC call) to a descriptive
            ;; map.
            rpc-methods (schema-&gt;methods schema)]
        {:rpc/version rpc-version
         :rpc/metadata rpc-metadata
         :rpc/servers rpc-servers
         :rpc/methods rpc-methods}))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
