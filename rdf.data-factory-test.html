<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">rdf.data-factory-test</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Test the conversion of RDF/js data factory instances into RDF/cljs data values.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns rdf.data-factory-test
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [&quot;rdf-data-factory&quot; :refer
    [DataFactory
     RDF.Term
     BlankNode
     DefaultGraph
     Literal
     NamedNode
     Variable
     Quad]])
  (:require
   [cljs.test :as t :refer [deftest is testing use-fixtures]]
   [clojure.string :as str])
  (:require
   [malli.core :as malli])
  (:require
   [com.kubelt.lib.rdf.data-factory :as rdf.df]
   [com.kubelt.spec.quad :as spec.quad]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Data</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def xml-string-uri
  &quot;http://www.w3.org/2001/XMLSchema#string&quot;)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def rdf-lang-uri
  &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#langString&quot;)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Utilities</h2>These convenience functions construct RDF/js instances of the variousTerm types.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a BlankNode RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn blank-node
  [value]
  {:pre [(string? value)]}
  (let [df (DataFactory.)]
    (.blankNode df value)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a NamedNode RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn named-node
  [value]
  {:pre [(string? value)]}
  (let [df (DataFactory.)]
    (.namedNode df value)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a Literal RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn literal
  ([value]
   {:pre [(string? value)]}
   (let [df (DataFactory.)]
     (.literal df value)))
  ([value language-datatype]
   {:pre [(string? value)
          (or (string? language-datatype)
              (rdf.df/named-node? language-datatype))]}
   (let [df (DataFactory.)]
     ;; If the literal has a language, its datatype has the
     ;; IRI &quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#langString&quot;. Otherwise,
     ;; if no datatype is explicitly specified, the datatype has the
     ;; IRI &quot;http://www.w3.org/2001/XMLSchema#string&quot;.
     (.literal df value language-datatype))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a Variable RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn variable
  [value]
  {:pre [(string? value)]}
  (let [df (DataFactory.)]
    (.variable df value)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a DefaultGraph RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn default-graph
  []
  (let [df (DataFactory.)]
    (.defaultGraph df)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Construct a Quad RDF/js Term.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn quad
  [subject predicate object graph]
  {:pre [(rdf.df/subject-term? subject)
         (rdf.df/predicate-term? predicate)
         (rdf.df/object-term? object)
         (rdf.df/graph-term? graph)]}
  [subject predicate object graph]
  (let [df (DataFactory.)]
    (.quad df subject predicate object graph)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Fixtures</h2>A fixture can run :once (before and after <em>all</em> tests are executed),or :each (before and after each individual test).
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">#_(use-fixtures :once
  {:before (fn [] (println &quot;start all&quot;))
   :after (fn [] (println &quot;done all&quot;))})
#_(use-fixtures :each
  {:before (fn [] (println &quot;start test&quot;))
   :after (fn [] (println &quot;done test&quot;))})
;; Predicate Tests
;; -----------------------------------------------------------------------------
;; Check that the predicate blank-node? correctly detects BlankNode
;; instances.
(deftest blank-node?-test
  (let [node (BlankNode.)]
    (testing &quot;with blank node&quot;
      (is (rdf.df/blank-node? node)))
    (testing &quot;with non-blank node&quot;
      (is (not (rdf.df/blank-node? {})))
      (is (not (rdf.df/blank-node? [])))
      (is (not (rdf.df/blank-node? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Check that the predicate named-node? correctly detects NamedNode instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest named-node?-test
  (let [node (NamedNode.)]
    (testing &quot;with named node&quot;
      (is (rdf.df/named-node? node)))
    (testing &quot;with non-named node&quot;
      (is (not (rdf.df/named-node? {})))
      (is (not (rdf.df/named-node? [])))
      (is (not (rdf.df/named-node? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Check that the predicate literal? correctly detects Literal instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest literal?-test
  (let [node (Literal.)]
    (testing &quot;with literal&quot;
      (is (rdf.df/literal? node)))
    (testing &quot;with non-literal&quot;
      (is (not (rdf.df/literal? {})))
      (is (not (rdf.df/literal? [])))
      (is (not (rdf.df/literal? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Check that the predicate variable? correctly detects Variable instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest variable?-test
  (let [node (Variable.)]
    (testing &quot;with variable&quot;
      (is (rdf.df/variable? node)))
    (testing &quot;with non-variable&quot;
      (is (not (rdf.df/variable? {})))
      (is (not (rdf.df/variable? [])))
      (is (not (rdf.df/variable? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Check that the predicate default-graph? correctly detects DefaultGraph instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest default-graph?-test
  (let [node (DefaultGraph.)]
    (testing &quot;with default graph&quot;
      (is (rdf.df/default-graph? node)))
    (testing &quot;with non-default graph&quot;
      (is (not (rdf.df/default-graph? {})))
      (is (not (rdf.df/default-graph? [])))
      (is (not (rdf.df/default-graph? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Check that the predicate quad? correctly detects Quad instances.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest quad?-test
  (let [quad (Quad.)]
    (testing &quot;with quad&quot;
      (is (rdf.df/quad? quad)))
    (testing &quot;with non-quad&quot;
      (is (not (rdf.df/quad? {})))
      (is (not (rdf.df/quad? [])))
      (is (not (rdf.df/quad? #{}))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO term?-test TODO subject-term?-test TODO predicate-term?-test TODO object-term?-test TODO graph-term?-test</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Node Tests</h2>TODO test named node with prefix.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Ensure that an RDF/js BlankNode instance is correctly converted to RDF/cljs.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest blank-node-test
  (testing &quot;with a non-prefixed blank node name&quot;
    ;; Test using a non-prefixed blank node name.
    (let [value &quot;b0&quot;
          node (blank-node value)
          term (rdf.df/blank-node-&gt;value node)]
      (is (map? term))
      (is (= :rdf.term/blank-node (:rdf/type term)))
      (is (= value (:value term)))
      (is (malli/validate spec.quad/blank-node term))))
  (testing &quot;with a prefixed blank node name&quot;
    ;; Test using a prefixed node name (having a prefix of &quot;_:&quot;). The
    ;; stored name value should be stripped of its prefix.
    (let [name &quot;b0&quot;
          prefixed (str/join &quot;:&quot; [&quot;_&quot; name])
          node (blank-node prefixed)
          term (rdf.df/blank-node-&gt;value node)]
      (is (map? term))
      (is (= :rdf.term/blank-node (:rdf/type term)))
      (is (= name (:value term)))
      (is (malli/validate spec.quad/blank-node term)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Ensure that an RDF/js NamedNode instance is correctly converted to RDF/cljs.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest named-node-test
  (let [value &quot;https://schema.org/url&quot;
        node (named-node value)
        term (rdf.df/named-node-&gt;value node)]
    (is (map? term))
    (is (= :rdf.term/named-node (:rdf/type term)))
    (is (= value (:value term)))
    (is (malli/validate spec.quad/named-node term))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Ensure that an RDF/js Literal instance is correctly converted to RDF/cljs.</p><p>NB: If the literal has a language, its datatype has the IRI "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString". Otherwise, if no datatype is explicitly specified, the datatype has the IRI "http://www.w3.org/2001/XMLSchema#string".</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest literal-test
  ;; Language is provided, not datatype; the datatype value must be
  ;; rdf-lang-uri.
  (testing &quot;with language&quot;
    (let [value &quot;cheese&quot;
          language &quot;en&quot;
          literal-term (literal value language)
          term (rdf.df/literal-&gt;value literal-term)]
      (is (map? term))
      (is (= :rdf.term/literal (:rdf/type term)))
      (is (= language (:language term)))
      (is (= value (:value term)))
      (is (malli/validate spec.quad/literal term))
      ;; Check that the datatype is converted to a RDF/cljs named node map
      ;; with the expected type URI (in this case, of an XML String).
      (let [term-datatype (:datatype term)]
        (is (map? term-datatype))
        (is (= :rdf.term/named-node (:rdf/type term-datatype)))
        (is (= rdf-lang-uri (:value term-datatype)))
        (is (malli/validate spec.quad/named-node term-datatype)))))
  ;; No language or datatype provided; the datatype URI should be
  ;; xml-string-uri.
  (testing &quot;with implicit datatype&quot;
    (let [value &quot;olives&quot;
          literal-term (literal value)
          term (rdf.df/literal-&gt;value literal-term)]
      (is (map? term))
      (is (= :rdf.term/literal (:rdf/type term)))
      (is (= value (:value term)))
      (is (not (contains? term :language)))
      (is (malli/validate spec.quad/literal term))
      ;; Check that the datatype is converted to a RDF/cljs named node
      ;; map with the expected type URI (in this case, xml-string-uri).
      (let [term-datatype (:datatype term)]
        (is (map? term-datatype))
        (is (= :rdf.term/named-node (:rdf/type term-datatype)))
        (is (= xml-string-uri (:value term-datatype)))
        (is (malli/validate spec.quad/named-node term-datatype)))))
  ;; An explicit datatype is provided; the datatype URI must match the
  ;; provided value.
  (testing &quot;with explicit datatype&quot;
    (let [value &quot;crackers&quot;
          example-uri &quot;http://example.org/some-type#rdf-string&quot;
          datatype (named-node example-uri)
          literal-term (literal value datatype)
          term (rdf.df/literal-&gt;value literal-term)]
      (is (map? term))
      (is (= :rdf.term/literal (:rdf/type term)))
      (is (= value (:value term)))
      (is (not (contains? term :language)))
      (is (malli/validate spec.quad/literal term))
      ;; Check that the datatype is converted to a RDF/cljs named node
      ;; map with the expected type URI (in this case, example-uri).
      (let [term-datatype (:datatype term)]
        (is (map? term-datatype))
        (is (= :rdf.term/named-node (:rdf/type term-datatype)))
        (is (= example-uri (:value term-datatype)))
        (is (malli/validate spec.quad/named-node term-datatype))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest variable-test
  ;; The variable is stored with any leading &quot;?&quot; stripped off.
  (testing &quot;with leading '?'&quot;
    (let [name &quot;a&quot;
          value (str &quot;?&quot; name)
          variable-term (variable value)
          term (rdf.df/variable-&gt;value variable-term)]
      (is (map? term))
      (is (= :rdf.term/variable (:rdf/type term)))
      (is (= name (:value term)))
      (is (malli/validate spec.quad/variable term))))
  ;; Handle variable names that are provided without a leading &quot;?&quot;.
  (testing &quot;without leading '?'&quot;
    (let [name &quot;a&quot;
          variable-term (variable name)
          term (rdf.df/variable-&gt;value variable-term)]
      (is (map? term))
      (is (= :rdf.term/variable (:rdf/type term)))
      (is (= name (:value term)))
      (is (malli/validate spec.quad/variable term)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest default-graph-test
  (let [graph-term (default-graph)
        term (rdf.df/default-graph-&gt;value graph-term)]
    (is (map? term))
    (is (= :rdf.term/default-graph (:rdf/type term)))
    (is (=  (:value term)))
    (is (malli/validate spec.quad/default-graph term))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest subject-test
  (testing &quot;with blank node&quot;
    ;; TODO)
  (testing &quot;with named node&quot;
    ;; TODO)
  (testing &quot;with variable&quot;
    ;; TODO)
  (testing &quot;with quad&quot;
    ;; TODO))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest predicate-test
  (testing &quot;with named node&quot;
    ;; TODO)
  (testing &quot;with variable&quot;
    ;; TODO))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest object-test
  (testing &quot;with blank node&quot;
    ;; TODO)
  (testing &quot;with named node&quot;
    ;; TODO)
  (testing &quot;with literal&quot;
    ;; TODO)
  (testing &quot;with variable&quot;
    ;; TODO))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest graph-test
  (testing &quot;with blank node&quot;
    ;; TODO)
  (testing &quot;with named node&quot;
    ;; TODO)
  (testing &quot;with variable&quot;
    ;; TODO)
  (testing &quot;with default graph&quot;
    ;; TODO))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(deftest quad-test
  (let [subject-value &quot;foo&quot;
        predicate-value &quot;bar&quot;
        var-name &quot;baz&quot;
        object-value (str &quot;?&quot; var-name)
        quad-term (quad (blank-node subject-value)
                        (named-node predicate-value)
                        (variable object-value)
                        (default-graph))
        term (rdf.df/quad-&gt;value quad-term)]
    (is (map? term))
    (is (= :rdf.term/quad (:rdf/type term)))
    (is (= subject-value (get-in term [:rdf.quad/subject :value])))
    (is (= predicate-value (get-in term [:rdf.quad/predicate :value])))
    (is (= var-name (get-in term [:rdf.quad/object :value])))
    (is (=  (get-in term [:rdf.quad/graph :value])))
    (malli/validate spec.quad/quad-schema term)))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
