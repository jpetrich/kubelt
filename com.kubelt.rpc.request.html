<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.rpc.request</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a method description and parameters into a transport (HTTP) request map.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc.request
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [com.kubelt.lib.json :as lib.json]
   [com.kubelt.lib.uuid :as lib.uuid]
   [com.kubelt.rpc.path :as rpc.path]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- http-request
  [body options]
  {:pre [(map? options)]}
  (let [version &quot;1.1&quot;
        ;; All RPC calls use POST.
        method :post
        user-agent (get options :http/user-agent )
        headers {&quot;Content-Type&quot; &quot;application/json&quot;
                 &quot;User-Agent&quot; user-agent}
        trailers {}
        scheme :http
        domain (:uri/domain options &quot;example.com&quot;)
        port (:uri/port options 33337)
        path (:uri/path options &quot;/foo&quot;)]
    {:com.kubelt/type :kubelt.type/http-request
     :http/version version
     :http/method method
     :http/headers headers
     :http/trailers trailers
     :http/body body
     :uri/scheme scheme
     :uri/domain domain
     :uri/port port
     :uri/path path}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a unique request identifier.</p><p>TODO use an integer stored in client for incrementing counter? Or perhaps a ULID / SQUUID to show calling sequence?</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- make-request-id
  []
  (lib.uuid/random))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- make-body
  [path method]
  {:pre [(rpc.path/path? path) (map? method)]}
  (let [;; Every RPC request must have a unique identifier.
        request-id (make-request-id)
        ;; The version of the JSON-RPC spec that we conform to.
        rpc-version &quot;2.0&quot;
        ;; The original name of the RPC method to call is stored in the
        ;; method map.
        method-name (get method :method/name)
        params []]
    (lib.json/edn-&gt;json-str
     {:id request-id
      :jsonrpc rpc-version
      :method method-name
      :params params})))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>from-method</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method descriptor map 'method' and a collection of parameters to bind, return a description of the RPC request to perform. The stored :rpc/path is the 'path' that names the RPC method, and the 'options' map is the same as that passed to the (init) call to initialize a client, values from which may be used in the process of creating the request, e.g. a user agent string, an HTTP host name, port, or path, etc. The :http/request value is an HTTP request map that is used to invoke the RPC call.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn from-method
  ([path method params]
   (let [defaults {}]
     (from-method path method params defaults)))
  ([path method params options]
   {:pre [(vector? path) (every? map? [method params options])]}
   ;; TODO allow specification of parameters as a sequence, in which
   ;; case the position of the parameter aligns with the parameter
   ;; definition list in the schema
   ;; TODO allow specification of parameters as a map, in which case the
   ;; map keys correspondond to the method parameter names.
   ;; TODO validate parameters
   (let [body (make-body path method)
         request (http-request body options)]
     {:com.kubelt/type :kubelt.type/rpc.request
      ;; TODO add a :rpc.param/&lt;name&gt; for each param that includes metadata,
      ;; schema, etc.
      ;; TODO add a :rpc.result that describes the expected result.
      :rpc/path path
      :rpc/method method
      :rpc/params params
      :http/request request})))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
