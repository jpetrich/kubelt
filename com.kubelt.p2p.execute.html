<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.p2p.execute</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Exploratory work towards using reitit.http wrapped around hypercores.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.p2p.execute
  {:copyright &quot;Â©2022 Kubelt, Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [&quot;http&quot; :as http :refer [IncomingMessage ServerResponse]])
  (:require
   [clojure.string :as str])
  (:require
   [cognitect.transit :as transit]
   [reitit.core :as route]
   [reitit.interceptor :as interceptor]
   [sieppari.core :as sieppari]
   [sieppari.queue :as queue]
   [taoensso.timbre :as log])
  (:require
   [com.kubelt.lib.http.media-type :as http.media-type]
   [com.kubelt.lib.http.request :as http.request]
   [com.kubelt.lib.http.status :as http.status]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Handlers</h2>TODO support transit as default formatTODO support edn as optional formatTODO support JSON as optional formatTODO content negotiation
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(comment
  (def r (transit/reader :json))
  (transit/write w [1 2 3])
  (transit/write w {:foo &quot;bar&quot;})
  (transit/read r &quot;[1,2,3]&quot;))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn on-complete
  [^ServerResponse res ctx]
  (let [status (-&gt; ctx :response :http/status)
        method (-&gt; ctx :request :http/method)
        ;;message (get http.status/message status)
        request-path (get-in ctx [:request :uri/path])]
    (log/info {:log/msg &quot;request received&quot;
               :request/method method
               :request/path request-path
               :response/status status})
    (if-let [body-edn (get-in ctx [:response :http/body])]
      ;; There's a response body to return; convert it to JSON and set
      ;; the response headers accordingly.
      (let [writer (transit/writer :json)
            response-body (transit/write writer body-edn)
            headers #js {&quot;Content-Type&quot; http.media-type/transit-json}]
        (doto res
          (.writeHead status headers)
          (.end response-body)))
      ;; There's no response body, so set the status only.
      (doto res
        (.writeHeader status)
        (.end)))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn on-error
  [^ServerResponse res ctx]
  ;; TODO
  (log/error &quot;error&quot;))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a request method and a route table entry, return the chain of interceptors to execute.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn extract-chain
  [method match-data]
  (letfn [;; Interceptors chains can be added to the route table as a
          ;; vector or map. If provided as a map, the map
          ;; key :interceptors should contain a vector of interceptors
          ;; to use for the route.
          (extract [m method-kw]
            ;; If no interceptor chain is specified for the given
            ;; method, we return an empty vector to signify nothing to
            ;; do.
            (if-some [chain (get m method-kw)]
              (if (map? chain)
                (if-some [interceptors (get chain :interceptors)] interceptors [])
                ;; User supplied a vector of interceptors, return it
                ;; without modification.
                chain)
              []))]
    (let [chain-all (extract match-data :http.method/all)
          method-kw (keyword :http.method method)
          chain-method (extract match-data method-kw)]
      ;; We don't want the presence of an :all chain to indicate that
      ;; all HTTP methods are supported. Instead, the chain is only
      ;; considered &quot;found&quot; if there's a chain corresponding to the
      ;; current request method; in that case we prepend the chain with
      ;; the contents of the :all chain.
      (if (seq chain-method)
        ;; The :all interceptors are always run first (on :enter) and
        ;; last (on :leave), if specified.
        (concat chain-all chain-method)
        []))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Set the HTTP status code of the response.</p><p>TODO move to context utility library.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn set-status
  [ctx status-code]
  (assoc-in ctx [:response :http/status] status-code))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn make-request-handler
  [config]
  (let [hyperbee (get config :hyper/bee)
        database (get config :db/memory)
        router (get config :http/router)]
    ;; This handler fn is invoked for each request received. It looks
    ;; for matching route in the route table and if it finds one,
    ;; retrieves the interceptor chain, sets up the request context, and
    ;; triggers the execution of the chain.
    (fn on-request
      [^IncomingMessage req ^ServerResponse res]
      (let [chunks #js []]
        (.on req &quot;data&quot;
             (fn [chunk]
               ;; Accumulate an array of request body data
               ;; chunks (Buffers).
               (.push chunks chunk)))
        (.on req &quot;end&quot;
             (fn []
               ;; We have accumulated the entire request body. Coalesce
               ;; into a single string/buffer and store as the raw request
               ;; body on the context. This makes the request body
               ;; available for content negotiation in interceptors.
               (let [;; TODO should this be stored as Buffer for raw?
                     raw-body (js/Buffer.concat chunks)
                     request-map (http.request/req-&gt;map req)
                     request-method (:http/method request-map)
                     request-path (:uri/path request-map)
                     context {:request request-map
                              :response {}
                              :body/raw (str raw-body)
                              :p2p/hyperbee hyperbee
                              :p2p/database database}]
                 ;; TODO handle match :path-params (+ :path :result :template)
                 (if-let [match (route/match-by-path router request-path)]
                   (if-let [;; NB: (seq) returns nil for empty collections.
                            int-chain (seq (extract-chain request-method (:data match)))]
                     (let [on-complete (partial on-complete res)
                           on-error (partial on-error res)
                           context (assoc context :match match)
                           ;; Need to convert for processing by sieppari; doesn't
                           ;; appear to accept a seq.
                           int-chain (into [] int-chain)]
                       ;; Execute the interceptor chain, calling either the
                       ;; completion or error callbacks.
                       (sieppari/execute-context int-chain context on-complete on-error))
                     ;; The route was matched but no interceptors found; tell the
                     ;; user they requested an unsupported method with a 405
                     ;; Method Not Allowed response.
                     (let [result (set-status context http.status/method-not-allowed)]
                       (on-complete res result)))
                   ;; No matching route found, return 404.
                   (let [result (set-status context http.status/not-found)]
                     (on-complete res result))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>TEMP</h2>Exploration of using reitit.http, ring-handler, etc. rather thanreitit.core.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(comment
  [reitit.http :as route]

  [&quot;/health&quot;
   [&quot;/live&quot;
    {:name ::liveness-check
     :interceptors [p2p.interceptor/status-ok]}]
   ;; TODO kubernetes readiness check
   [&quot;/ready&quot;
    {:name ::readiness-check
     :interceptors [p2p.interceptor/example p2p.interceptor/status-ok]
     :get {:interceptors [p2p.interceptor/example]}}]]

  (let [default-handler (fn [request]
                          {:body &quot;xxx&quot; :status 200})
        route-table (route/router routes)
        ;; Optional sequence of interceptors run before any other
        ;; interceptors, even for the default handler.
        ;; TODO good place to authenticate requests, etc.
        interceptors []]
    (prn (goog.object/getKeys route-table))
    ;;(prn (type (first (goog.object/get route-table &quot;routes&quot;))))
    (try
      (route/ring-handler
       route-table
       #_default-handler
       {:executor p2p.execute/executor
        :interceptors interceptors})
      (catch js/Error e
        (prn e))))

  (extend-type js/Object
    reitit.interceptor/IntoInterceptor
    (into-interceptor [this data opts]
      (let []
        (reitit.interceptor/map-&gt;Interceptor
         {:name ::fixme
          :enter (fn [ctx]
                   (prn &quot;compiled&quot;)
                   ctx)}))))

  (let [request {:request-method request-method :uri request-path}
        result (api request)]
    ))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(def executor
  (reify
    interceptor/Executor
    (queue [_ interceptors]
      (queue/into-queue
       (map
        (fn [{::interceptor/keys [handler] :as interceptor}]
          (or handler interceptor))
        interceptors)))
    ;; This arity doesn't appear to be supported in CLJS.
    ;; We should support it, passing in our default callbacks.
    #_(execute [_ interceptors request]
        (sieppari/execute interceptors request))
    (execute [_ interceptors request respond raise]
      (sieppari/execute-context interceptors request respond raise))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
