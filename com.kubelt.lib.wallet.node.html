<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.lib.wallet.node</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>The Node.js implementation of a crypto wallet wrapper.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.wallet.node
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:refer-clojure :exclude [import])
  (:require
   [&quot;fs&quot; :as fs]
   [&quot;path&quot; :as path])
  (:require
   [&quot;@ethersproject/wallet&quot; :refer [Wallet]])
  (:require
   [cljs.core.async :as async :refer [go]]
   [cljs.core.async.interop :refer-macros [&lt;p!]])
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.path :as lib.path]
   [com.kubelt.lib.promise :as lib.promise]
   [com.kubelt.lib.wallet.shared :as lib.wallet]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the wallet directory path as a string for an application.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- wallet-dir
  [app-name]
  (let [config-path (lib.path/data app-name)
        wallet-path (.join path config-path &quot;wallets&quot;)]
    wallet-path))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the wallet directory path for the application as a string, creating it if it doesn't already exist.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- ensure-wallet-dir
  [app-name]
  (let [wallet-dirp (wallet-dir app-name)]
    (when-not (.existsSync fs wallet-dirp)
      (let [mode &quot;0700&quot;
            recursive? true
            options #js {:mode mode
                         :recursive recursive?}]
        (.mkdirSync fs wallet-dirp options)))
    wallet-dirp))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return the path to a wallet given the owning application name and wallet name.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- name-&gt;path
  [app-name wallet-name]
  (let [wallet-path (wallet-dir app-name)
        wallet-path (.join path wallet-path wallet-name)]
    wallet-path))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the named wallet has the correct permissions, false otherwise.</p><p>Unused predicate</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- valid-perms?
  [app-name wallet-name]
  (let [read-ok (.. fs -constants -R_OK)
        write-ok (.. fs -constants -W_OK)
        perms (bit-or read-ok write-ok)
        wallet-path (name-&gt;path app-name wallet-name)]
    (try
      (.accessSync fs wallet-path read-ok)
      (catch js/Error e
        false))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>TODO allow wallet re-creation from mnemonicTODO allow wallet listingTODO allow wallet deletion
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the named wallet already exists.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn has-wallet?
  [app-name wallet-name]
  (let [wallet-path (name-&gt;path app-name wallet-name)]
    (.existsSync fs wallet-path)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return true if the wallet can be successfully decrypted with the supplied password, and false otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn can-decrypt?
  [app-name wallet-name password]
  (if (has-wallet? app-name wallet-name)
    (let [wallet-path (name-&gt;path app-name wallet-name)
          wallet-str (.readFileSync fs wallet-path)]
      (try
        (.fromEncryptedJsonSync Wallet wallet-str password)
        true
        (catch js/Error e
          ;; Error: invalid password
          false)))
    false))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Create and store an encrypted wallet. The encrypted wallet file is stored in an XDG compliant location based on the application name. It is also named using the supplied wallet name and encrypted with the supplied password. A map describing the created wallet is returned if successful. An error map is returned otherwise.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  [app-name wallet-name password]
  (let [;; Create the wallet directory if it doesn't already exist.
        wallet-dirp (ensure-wallet-dir app-name)]
    ;; It's an error to initialize an existing wallet.
    (when (has-wallet? app-name wallet-name)
      (let [message (str &quot;wallet &quot; wallet-name &quot; already exists&quot;)]
        (lib.error/error message)))
    ;; Wallet doesn't yet exist, so create it!
    (let [wallet-path (.join path wallet-dirp wallet-name)
          eth-wallet (.createRandom Wallet)
          mnemonic (.-mnemonic eth-wallet)]
      (go
        (let [wallet-js (&lt;p! (.encrypt eth-wallet password))]
          (.writeFileSync fs wallet-path wallet-js)))
      (let [{:keys [phrase path locale]} (js-&gt;clj mnemonic :keywordize-keys true)]
        {:wallet/path wallet-path
         :wallet/name wallet-name
         :wallet.mnemonic/phrase phrase
         :wallet.mnemonic/path path
         :wallet.mnemonic/locale locale}))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a promise that resolves to a wallet map, or that rejects with an error map if a problem occurs.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn load
  [app-name wallet-name password]
  (let [wallet-dirp (ensure-wallet-dir app-name)]
    (lib.promise/promise
     (fn [resolve reject]
       (when-not (has-wallet? app-name wallet-name)
         (let [message (str &quot;wallet &quot; wallet-name &quot; doesn't exist&quot;)]
           (reject (lib.error/error message))))
       ;; Load the wallet JSON
       (let [wallet-path (name-&gt;path app-name wallet-name)]
         (.readFile fs wallet-path &quot;utf8&quot;
          (fn [err wallet-str]
            (if err
              (reject (lib.error/error err))
              (let [eth-wallet (.fromEncryptedJsonSync Wallet wallet-str password)
                    address (.-address eth-wallet)
                    sign-fn (lib.wallet/make-sign-fn eth-wallet)]
                (resolve
                 {:com.kubelt/type :kubelt.type/wallet
                  :wallet/address address
                  :wallet/sign-fn sign-fn}))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a list of wallet names.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn ls
  [app-name]
  (let [wallet-dirp (ensure-wallet-dir app-name)
        wallet-files (.readdirSync fs wallet-dirp)]
    (js-&gt;clj wallet-files)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Delete a wallet.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn delete!
  [app-name wallet-name]
  (let [wallet-path (name-&gt;path app-name wallet-name)]
    (.unlinkSync fs wallet-path)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn create
  []
  :fixme
  ;; (&lt;! (lib.wallet/random-wallet))
  #_(let [sign-fn (lib.wallet/make-sign-fn eth-wallet)]
    {:wallet/address :fixme
     :wallet/sign-fn sign-fn}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Import a wallet and store it encrypted. Returns a promise that resolves to the path to the imported wallet, or if an error occurs rejects with a standard error map.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn import
  [app-name wallet-name mnemonic password]
  (lib.promise/promise
   (fn [resolve reject]
     (when (has-wallet? app-name wallet-name)
       (let [msg (str &quot;wallet &quot; wallet-name &quot; already exists&quot;)
             error (lib.error/error msg)]
         (reject error)))
     ;; The wallet with the given name doesn't yet exist, we can import
     ;; from the mnemonic and create a wallet with that name.
     (letfn [;; Returns a promise that resolves to the wallet
             ;; JSON. Throws if the mnemonic is invalid.
             (from-mnemonic [mnemonic]
               (try
                 (let [w (.fromMnemonic Wallet mnemonic)]
                   ;; Returns a promise.
                   (.encrypt w password))
                 (catch js/Error e
                   (let [error (lib.error/from-obj e)]
                     (reject error)))))
             ;; Returns the path of the wallet file to write.
             (wallet-path []
               (let [wallet-dir (ensure-wallet-dir app-name)
                     wallet-file (.join path wallet-dir wallet-name)]
                 (lib.promise/resolved wallet-file)))]
       (let [path&amp; (wallet-path)
             wallet&amp; (from-mnemonic mnemonic)]
         (-&gt; (lib.promise/all [path&amp; wallet&amp;])
             (.then (fn [[wallet-dirp wallet-js]]
                      (try
                        (.writeFileSync fs wallet-dirp wallet-js)
                        (let [result {:wallet/name wallet-name
                                      :wallet/path wallet-path}]
                          (resolve result))
                        (catch js/Error e
                          (let [error (lib.error/from-obj e)]
                            (reject error))))))
             (.catch (fn [e]
                       (let [error (lib.error/from-obj e)]
                         (reject error))))))))))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
