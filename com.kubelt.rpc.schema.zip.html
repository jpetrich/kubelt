<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.rpc.schema.zip</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>A zipper for traversnig and editing OpenRPC schemas.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc.schema.zip
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [clojure.zip :as zip]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>TODO test test test</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>map-entry</h2>Construct a map entry.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- map-entry
  [k v]
  #?(:clj (clojure.lang.MapEntry/create k v)
     :cljs (cljs.core/MapEntry. k v nil)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>branch?</h2>An OpenRPC schema is defined as JSON, which we see after parsing intoedn. Therefore the only collection types we need to care about areJSON arrays and objects which after parsing are vectors and maps,with the possible addition of sets, which result result from somepost-parsing transformation.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- branch?
  [node]
  (cond
    ;; Non-collection types have no children.
    (not (coll? node))
    false
    ;; If we're looking at a map entry, the children are to be found
    ;; in the value, assuming it's a collection of some sort.
    (map-entry? node)
    (coll? (val node))
    ;; We can expect to see maps and vectors after parsing JSON; some of
    ;; our schema-related transformations may consolidate a collection
    ;; into a set.
    :else
    (or (map? node) (vector? node) (set? node))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>children</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Returns a seq of the children of a branch node. The only types we see here are those for which (branch?) returns true, so in this case maps, sets, vectors, and map entries.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- children
  [node]
  (seq (cond
         ;; map, vector, set
         (or (map? node) (vector? node) (set? node))
         node
         ;; map entry with a collection value
         (and (map-entry? node) (coll? (val node)))
         (val node))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>make-node</h2>Given an existing node and a seq of children, return new branch nodewith the supplied children.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- make-node
  [node children]
  ;; NB: the painful bug we saw before resulted from having these (cond)
  ;; branches in the opposite order, i.e. checking for a (map-entry?
  ;; node) *after* checking if the node was one of the supported
  ;; collection types. Dig into this a bit to make sure we understand
  ;; why that is.
  (cond
    ;; If x is not a map, set, or vector it can only be map entry.
    (map-entry? node)
    (let [k (key node)
          v (into (empty (val node)) (-&gt; children rest first))]
      (map-entry k v))
    ;; map, vector, set.
    (or (map? node) (vector? node) (set? node))
    (into (empty node) children)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>ref-loc?</h2>A reference is a map with a :\$ref key, whose value is a stringreference to another location in the schema, e.g.{:\$ref "#/components/examples/fooBar"}.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn ref-loc?
  [loc]
  (let [node (zip/node loc)]
    (and (map? node) (contains? node :\$ref))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>schema-zip</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a zipper over a parsed OpenRPC schema document.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn schema-zip
  [root]
  (zip/zipper branch? children make-node root))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
