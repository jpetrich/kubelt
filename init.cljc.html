<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">init.cljc</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>SDK system map implementation.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.lib.init
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [integrant.core :as ig]
   [taoensso.timbre :as log])
  (:require
   [com.kubelt.ipfs.client :as ipfs.client]
   [com.kubelt.lib.jwt :as lib.jwt]
   [com.kubelt.lib.multiaddr :as lib.multiaddr]
   [com.kubelt.lib.vault :as lib.vault]
   [com.kubelt.lib.wallet :as lib.wallet]
   [com.kubelt.proto.http :as proto.http])
  (:require
   #?@(:browser [[com.kubelt.lib.http.browser :as http.browser]]
       :node [[com.kubelt.lib.http.node :as http.node]]
       :clj [[com.kubelt.lib.http.jvm :as http.jvm]])))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>System</h2>For each key in the system map, if a corresponding method isimplemented for the ig/init-key multimethod it will be invoked inorder to initialize that part of the system. The return value isstored as part of the system configuration map. Initialization isperformed recursively, making it possible to have nested subsystems.<p>If methods are defined for the ig/halt-key! multimethod, they are invoked in order to tear down the system in the reverse order in which it was initialized.</p><p>To begin the system:   (integrant.core/init) To stop the system:   (integrant.core/halt!)</p><p>Cf. https://github.com/weavejester/integrant.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:log/level</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :log/level [_ log-level]
  ;; Initialize the logging system.
  (when log-level
    (log/merge-config! {:min-level log-level}))
  log-level)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :log/level [_ log-level]
  (log/debug {:log/msg &quot;halt logging&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/read-addr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/multiaddr [_ address]
  ;; Return the multiaddress string.
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/read-scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.read/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/write-addr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/multiaddr [_ address]
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:ipfs/write-scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :ipfs.write/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/multiaddr</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/multiaddr [_ address]
  address)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:p2p/scheme</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :p2p/scheme [_ scheme]
  scheme)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:credential/jwt</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :credential/jwt [_ tokens]
  tokens)</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/http</h2>TODO support custom user agent string.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/http [_ value]
  {:post [(not (nil? %))]}
  (log/debug {:log/msg &quot;init HTTP client&quot;})
  #?(:browser (http.browser/-&gt;HttpClient)
     :node (http.node/-&gt;HttpClient)
     :clj (http.jvm/-&gt;HttpClient)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/http [_ client]
  {:pre [(satisfies? proto.http/HttpClient client)]}
  (log/debug {:log/msg &quot;halt HTTP client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/ipfs</h2>Send headers with each request: token "xyzabc123" authorization (str "Bearer " token) user-agent "X-Kubelt" headers {:headers {:authorization authorization<pre><code>                :user-agent user-agent}}</code></pre>Use an http.Agent (node-only) to control client behavior:  agent {:agent (.. http Agent.)}
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/ipfs [_ value]
  (let [;; Supply the address of the IPFS node(s). Read and write can
        ;; use different paths if desired, e.g. when you want to read
        ;; from a local daemon but write to a remote service for
        ;; pinning.
        read-addr (get-in value [:ipfs/read :ipfs/multiaddr])
        read-map (lib.multiaddr/str-&gt;map read-addr)
        read-host (:address/host read-map)
        read-port (:address/port read-map)
        read-scheme (get-in value [:ipfs/read :http/scheme])
        write-addr (get-in value [:ipfs/write :ipfs/multiaddr])
        write-map (lib.multiaddr/str-&gt;map write-addr)
        write-host (:address/host write-map)
        write-port (:address/port write-map)
        write-scheme (get-in value [:ipfs/write :http/scheme])
        ;; Get the platform-specific HTTP client.
        http-client (get value :client/http)]
    (let [ipfs-read (str (name read-scheme) &quot;://&quot; read-addr)
          ipfs-write (str (name write-scheme) &quot;://&quot; write-addr)]
      (log/debug {:log/msg &quot;init IPFS client&quot; :ipfs/read ipfs-read :ipfs/write ipfs-write}))
    (try
      ;; Create the options object we pass to client creation fn.
      (let [options {:http/client http-client
                     :read/scheme read-scheme
                     :read/host read-host
                     :read/port read-port
                     :write/scheme write-scheme
                     :write/host write-host
                     :write/port write-port
                     ;; Set a global timeout for *all* requests:
                     ;;:client/timeout 5000
                     }]
        (ipfs.client/init options))
      (catch js/Error e
        (log/fatal e))
      (catch :default e
        (log/error {:log/msg &quot;unexpected error&quot; :error/value e})))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/ipfs [_ client]
  (log/debug {:log/msg &quot;halt IPFS client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:client/p2p</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :client/p2p [_ {:keys [http/scheme p2p/multiaddr] :as value}]
  ;; If we wanted to initialize a stateful client for the p2p system,
  ;; this would be the place. Since that system exposes a stateless HTTP
  ;; API, we'll just convert the multiaddresses we're given for the p2p
  ;; read/write nodes into more conventional coordinates (host, port) in
  ;; the system configuration map and pull them out when we need to make
  ;; a call.
  (let [p2p-addr (str (name scheme) &quot;://&quot; multiaddr)]
    (log/debug {:log/msg &quot;init p2p client&quot; :p2p/address p2p-addr}))
  (let [;; Get the multiaddr string and convert into a map
        ;; containing {:address/host :address/port}.
        address (lib.multiaddr/str-&gt;map multiaddr)
        host (get address :address/host)
        port (get address :address/port)]
    (-&gt; value
        (assoc :http/scheme scheme)
        (assoc :http/host host)
        (assoc :http/port port))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :client/p2p [_ value]
  (log/debug {:log/msg &quot;halt p2p client&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/session</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/session [_ {:keys [jwt/tokens]}]
  (log/debug {:log/msg &quot;init session&quot;})
  ;; If any JWTs are provided, parse them and store the decoded result.
  (let [tokens (reduce (fn [m [core token]]
                         (let [decoded (lib.jwt/decode token)]
                           (assoc m core decoded)))
                       {}
                       tokens)]
    ;; Our session storage map is a &quot;vault&quot;.
    (lib.vault/vault tokens)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/session [_ session]
  (log/debug {:log/msg &quot;halt session&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>:crypto/wallet</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/init-key :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;init wallet&quot;})
  (if-not (lib.wallet/valid? wallet)
    (throw (ex-info &quot;invalid wallet&quot; wallet))
    wallet))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defmethod ig/halt-key! :crypto/wallet [_ wallet]
  (log/debug {:log/msg &quot;halt wallet&quot;}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>Public</h2>NB: the configuration map is validated by the exposed SDK methods.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Initialize the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn init
  [system-config]
  (ig/init system-config))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Clean-up resources used by the SDK.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn halt!
  [sys-map]
  (ig/halt! sys-map))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
