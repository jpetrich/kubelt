<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" content="text/html" http-equiv="Content-Type" />
		<meta content="" name="description" />
		<title>Kubelt SDK Reference</title>
 		<link rel="stylesheet" type="text/css" href="css/shCore.css" />
		<style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style>
		<link rel="stylesheet" type="text/css" href="css/shThemeMarginalia.css" />
		<link rel="stylesheet" type="text/css" href="css/marginalia.css" />
		<script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
		<script type="text/javascript" src="js/xregexp-min.js"></script>
		<script type="text/javascript" src="js/shCore.js"></script>
		<script type="text/javascript" src="js/shBrushClojure.js"></script>
	</head>
	<body>
		<table>
			<tr>
				<td class="docs">
					<div class="docs-header">
						<a class="anchor" href="#repl" name="repl">
							<h1 class="project-name">com.kubelt.rpc.request</h1>
							<a class="toc-link" href="index.html">toc</a>
						</a>
					</div>
				</td>
				<td class="codes" />
			</tr>
			<tr>
				<td class="docs">
					<p>Convert a method description and parameters into a transport (HTTP) request map.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(ns com.kubelt.rpc.request
  {:copyright &quot;Â©2022 Proof Zero Inc.&quot; :license &quot;Apache 2.0&quot;}
  (:require
   [com.kubelt.lib.error :as lib.error]
   [com.kubelt.lib.json :as lib.json]
   [com.kubelt.lib.uuid :as lib.uuid]
   [com.kubelt.rpc.path :as rpc.path]))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- http-request
  [body options]
  {:pre [(map? options)]}
  (let [version &quot;1.1&quot;
        ;; All RPC calls use POST.
        method :post
        user-agent (get options :http/user-agent )
        headers (merge
                 {&quot;Content-Type&quot; &quot;application/json&quot;
                  &quot;User-Agent&quot; user-agent}
                 (when-let [jwt (:rpc/jwt options)]
                   {&quot;KBT-Access-JWT-Assertion&quot; jwt}))
        trailers {}
        scheme (:uri/scheme options :http)
        domain (:uri/domain options &quot;example.com&quot;)
        port (:uri/port options 33337)
        path (:uri/path options &quot;/foo&quot;)]
    {:com.kubelt/type :kubelt.type/http-request
     :http/version version
     :http/method method
     :http/headers headers
     :http/trailers trailers
     :http/body body
     :uri/scheme scheme
     :uri/domain domain
     :uri/port port
     :uri/path path}))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Return a unique request identifier.</p><p>TODO use an integer stored in client for incrementing counter? Or perhaps a ULID / SQUUID to show calling sequence?</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- make-request-id
  []
  (lib.uuid/random))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn- make-body
  [path method params]
  {:pre [(rpc.path/path? path) (every? map? [method params])]}
  (let [;; Every RPC request must have a unique identifier.
        request-id (make-request-id)
        ;; The version of the JSON-RPC spec that we conform to.
        rpc-version &quot;2.0&quot;
        ;; The original name of the RPC method to call is stored in the
        ;; method map.
        method-name (get method :method/name)
        ;; Get the list of keywords representing every parameter
        ;; supported by this RPC method.
        all-params (get method :method.params/all)
        ;; Collect parameters from the supplied parameter map, removing
        ;; any nil entries.
        params (filter some? (map #(get params %) all-params))]
    (lib.json/edn-&gt;json-forjs-str
     {:id request-id
      :jsonrpc rpc-version
      :method method-name
      :params params})))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>from-params-map</h2>Given a map of parameters from keyword parameter name to parametervalue, validate that the map has the required parameters and returnit if so. Otherwise, return an error map.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn from-params-map
  [method params]
  {:pre [(every? map? [method params])]}
  ;; TODO check that all required params were supplied
  ;; TODO Check for extraneous parameters (only if :strict? option enabled)
  (let [;; TODO validate parameter value against schema.
        param-valid? (constantly true)]
    (into {} (map (fn [[param-kw param-val :as pair]]
                    (if-let [param (get-in method [:method/params param-kw])]
                      (let [result (param-valid? param param-val)]
                        (if (lib.error/error? result)
                          [param-kw result]
                          pair))
                      [param-kw (lib.error/error &quot;no such parameter&quot; {:parameter param-kw})]))
                  params))))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>from-params-vec</h2>Given a vector of parameter values for a method, and a map describingthe method, return a map from parameter name to parametervalue. E.g. if the method has parameters [:a :b], and we are giventhe parameters [:x :y], return {:a :x, :b :y}, or an error map ifsome error occurred.
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn from-params-vec
  [method params]
  {:pre [(map? method) (vector? params)]}
  (let [;; A vector of parameter names (as keywords).
        params-kw (get method :method.params/all)
        ;; A map from parameter name to parameter value.
        params-map (zipmap params-kw params)]
    (from-params-map method params-map)))</pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<h2>from-method</h2>
				</td>
				<td class="codes">
					<pre class="brush: clojure"></pre>
				</td>
			</tr>
			<tr>
				<td class="docs">
					<p>Given a method descriptor map 'method' and a collection of parameters to bind, return a description of the RPC request to perform. The stored :rpc/path is the 'path' that names the RPC method, and the 'options' map is the same as that passed to the (init) call to initialize a client, values from which may be used in the process of creating the request, e.g. a user agent string, an HTTP host name, port, or path, etc. The :http/request value is an HTTP request map that is used to invoke the RPC call.</p>
				</td>
				<td class="codes">
					<pre class="brush: clojure">(defn from-method
  ([path method params]
   (let [defaults {}]
     (from-method path method params defaults)))
  ([path method params options]
   {:pre [(vector? path) (every? map? [method params options])]}
   (let [body (make-body path method params)
         request (http-request body options)]
     ;; TODO should we merge the method map into the result, rather than
     ;; storing it as the value of the :rpc/method key?
     {:com.kubelt/type :kubelt.type/rpc.request
      ;; TODO add a :rpc.param/&lt;name&gt; for each param that includes metadata,
      ;; schema, etc.
      ;; TODO add a :rpc.result that describes the expected result.
      :rpc/path path
      :rpc/method method
      :rpc/params params
      :http/request request})))</pre>
				</td>
			</tr>
			<tr>
				<td class="spacer docs">&nbsp;</td>
				<td class="codes" />
			</tr>
		</table>
		<div class="footer">Generated by <a href="https://github.com/captain-porcelain/sidenotes">Sidenotes</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a>
		</div>
		<script type="text/javascript" src="js/app.js"></script>
	</body>
</html>
